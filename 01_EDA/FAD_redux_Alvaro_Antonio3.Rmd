---
title: "FAD Memoria: EDA & LR"
author: "Alvaro Simón Merino, Antonio Fernández Cáceres, Katsiaryna Zaitsava"
date: "15/12/2021"
output:
  html_document: 
    theme:
      bg: "#FFFAFA"
      fg: "#262626"
      primary: "#838B8B"
      secondary: "#333333"
      output_bg: "#999999"
      code_font: 
        google: Open Sans
      base_font:
        google: Source Sans Pro
      heading_font:
        google: Roboto
    code_folding: hide
    toc: yes
    toc_float: yes
    df_printed: paged
    self_contained: true
  pdf_document: 
    theme: united
    code_folding: "hide"
    toc: yes
    toc_float: yes
editor_options: 
  markdown: 
    wrap: sentence
---

------------------------------------------------------------------------

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

[![Haz click para abrir el mapa de Madrid de Airbnb](images/Madrid.jpg "Madrid")](http://insideairbnb.com/madrid/?neighbourhood=&filterEntireHomes=false&filterHighlyAvailable=false&filterRecentReviews=false&filterMultiListings=false)

```{r include, message=FALSE, warning=FALSE}
library(caret)
library(dplyr)
library(ggplot2)
library(stringr)
library(readr)
library(batman)
library(knitr)
library(tidyr)
library(PASWR2)
library(scales)
library(nortest)
library(kableExtra) # sudo apt install libfontconfig1-dev
library(cowplot)
library(mice)
library(VIM)
library(ggcorrplot)
library(psych)
library(ipred)
library(car)
library(geojsonio)
library(gridExtra)
library(shiny)
library(GGally)
library(RColorBrewer)
library(ggExtra)
library(DMwR) # install.packages(c("zoo","xts","quantmod")), luego instala ROCR, luego install.packages( "Path/To/DMwR_0.4.1.tar.gz", repos=NULL, type="source" )
library(geosphere)
```

<br/> <br/>

## Definición de objetivos

Para la realización de esta práctica se ha seleccionado el dataset *listings.csv* (Airbnb Madrid, 2021-09-10), un conjunto de datos obtenido de [insideairbnb.com](http://insideairbnb.com/).
Puede ser descargado a través de este [enlace](http://data.insideairbnb.com/spain/comunidad-de-madrid/madrid/2021-09-10/data/listings.csv.gz).

El objetivo general de esta práctica es proponer un modelo de regresión lineal multivariante para predecir el precio por noche de un espacio ofertado en la plataforma *AirBnb* y situado en Madrid.
<br/>

Dicho objetivo, a su vez se dividirá en los siguientes pasos:

1.  Selección preliminar de variables.
2.  Separación del conjunto de datos en dos grupos: Training (70% de los datos) y Test (30% de los datos)
3.  Realización de un análisis exploratorio univariante de los datos.
4.  Estudio e imputación de datos faltantes.
5.  Realización de un análisis exploratorio multivariante de los datos.
6.  Transformaciones necesarias a cada una de las variables para poder ser utilizadas en la regresión.
7.  Ajuste, aplicación y evaluación de un modelo de regresión lineal múltiple con las variables seleccionadas para la predicción de la variable $price$.

<br/> <br/>

## Selección preliminar de variables

```{r warning=FALSE, , message=FALSE, include=FALSE}
RawData <- read.csv("../00_DatosOriginales/listings.csv")
```

El conjunto de datos original está formado por un total de `r nrow(RawData)` datos y `r ncol(RawData)` variables, que son:

```{r message=FALSE, warning=FALSE, paged.print=TRUE, echo=FALSE}
col_name <- colnames(RawData)
kable(as.matrix(col_name)) %>%
  kable_styling("striped") %>% 
  scroll_box(width = "100%", height = "350px")
```

<br/>

Basándonos en un conocimiento preliminar proporcionado por la plataforma sobre el contenido de las variables, se seleccionarán aquellas consideradas de potencial interés para la realización del modelo:

```{r datos, message=FALSE, warning=FALSE, paged.print=TRUE}
data <- RawData %>%
   select(id, host_id, host_since, host_is_superhost, description, neighbourhood_group_cleansed, latitude, longitude, property_type, room_type, accommodates, bedrooms, beds, price, minimum_nights, minimum_nights_avg_ntm, maximum_nights_avg_ntm, availability_365, last_review, review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month)

# Corrección de tipos

data$host_since <- as.Date(data$host_since)
data$last_review <- as.Date(data$last_review)

data$host_is_superhost <- as.character(data$host_is_superhost)
data$host_is_superhost[which(data$host_is_superhost == "")] <- NA
data$host_is_superhost[which(data$host_is_superhost == "t")] <- "true"
data$host_is_superhost[which(data$host_is_superhost == "f")] <- "false"
data$host_is_superhost <- to_logical(data$host_is_superhost)

data$price <- as.character(data$price)
data$price<-parse_number(data$price)

data$description <- as.character(data$description)
data$description[which(data$description == "")] <- NA


# Eliminación de observaciones inverosímiles

data <- data[data$price>0 & data$accommodates>0,]


# Selección de variables de interés
   
voi <- data.frame("Variable" = c("host_id", "host_since", "host_is_superhost", "description", "neighbourhood_group_cleansed", "latitude", "longitude", "property_type", "room_type", "accommodates", "bedrooms", "beds", "price", "minimum_nights", "minimum_nights_avg_ntm", "maximum_nights_avg_ntm", "availability_365", "last_review", "review_scores_rating", "review_scores_accuracy", "review_scores_cleanliness", "review_scores_checkin", "review_scores_communication", "review_scores_location", "review_scores_value", "reviews_per_month"),
         
                  "Definición" = c("identificador único de cada arrendador", "fecha en que el arrendador se dio de alta en la plataforma","indicador lógico de si el arrendador tiene excelentes puntuaciones","descripción del espacio alquilable","distrito en que se encuentra el espacio alquilable","coordenada de latitud del espacio alquilable","coordenada de longitud del espacio alquilable","tipo de propiedad","tipo de habitación","capacidad máxima del espacio","número de cuartos de baño","número de camas de la habitación","precio por noche en moneda local","mínimo de noches por estancia","promedio de mínimo de noches durante los próximos 365 días","promedio de máximo de noches durante los próximos 365 días","disponibilidad del espacio durante los próximos 365 días","fecha de la última puntuación","puntuación general del espacio","puntuación sobre la realidad/descripción del espacio","puntuación sobre la limpieza del espacio","puntuación sobre el checkin","puntuación sobre lo bien que está comunicado el espacio","puntuación de la localización del espacio","puntuación del valor del espacio","media de número de reviews por espacio durante un mes"))

voi$Tipo <- sapply(data[,voi$Variable],class)
voi <- voi[,c(1,3,2)]

kable(voi) %>% kable_styling("striped") %>%
  scroll_box(width = "100%", height = "350px")

```

Aunque se intuye antes de comenzar que hay variables que van a aportar poca información o son similares a otras o combinaciones de varias, de momento se conservarán cara a realizar un análisis previo para justificar su inclusión o exclusión de nuestro estudio.

<br/>

## Separación del conjunto de datos en dos grupos

Se procede a dividir el conjunto de datos en dos partes: el 70% para grupo de Training y 30% para grupo de Test.
No se considera necesario un muestreo estratificado debido a que el número de observaciones es grande.
Se hará de manera pseudoaleatoria:

```{r slice, message=FALSE, warning=FALSE}
set.seed(12345)
inTraining <- createDataPartition(pull(RawData, neighbourhood_group_cleansed),
                                  p = .7, list = FALSE, times = 1)
data_train <- slice(data, inTraining)
data_test <- slice(data, -inTraining)

groups <- data.frame("Grupos" = c("Training","Test"), "Observaciones" = c(nrow(data_train),nrow(data_test)), "Porcentaje" = c(round(nrow(data_train)*100/nrow(data),1),round(nrow(data_test)*100/nrow(data),1)))

kable(groups) %>% kable_styling("striped")
```

<br/>

A partir de ahora, y hasta que se ponga a prueba el modelo, se utilizarán exclusivamente los datos del grupo de Training.

<br/> <br/>

## Análisis exploratorio univariante

<br/>

#### **Variable objetivo: price**

La variable $price$, la cual queremos predecir, en general se concentra entre los 37 y los 105€, y en general el número de Airbnbs decrece con el precio:

```{r precios, message=FALSE, warning=FALSE, fig.align="center"}
price <- ggplot(data_train, aes(x=price, y=..density..)) + geom_histogram(binwidth = 10, fill='cadetblue4') + geom_density(alpha = .1, fill="white")

log_price <- ggplot(data_train, aes(x=price, y=..density..)) + geom_histogram(binwidth = 10, color='white', fill='cadetblue4') + geom_density(alpha = .1, color="#FFA500", fill="white") + xlim(c(0,500)) + ggtitle('Transformación logarítmica')

boxplot_price <- ggplot(data_train, aes(y=price)) + geom_boxplot(color="#FFA500", fill='cadetblue4') + scale_y_continuous(trans='log10')

quantile_price <- data.frame(quantile(data_train$price))

colnames(quantile_price) <- c("Observaciones")

tbl <- tableGrob(quantile_price)

grid.arrange(price, log_price,boxplot_price,tbl, ncol=2, nrow =2, as.table=TRUE)
```

El precio medio por noche es de `r round(mean(data$price),2)` €.
El precio mínimo es `r min(data$price)`€, y el precio máximo es de `r max(data$price)`€.
Se ha comprobado accediendo a la plataforma que valores tan altos no tienen por qué ser erróneos.
Sin embargo, se observa que la distribución posee una cola muy larga en su lado derecho, lo cual puede dar problemas a la hora de realizar la regresión.

<br/>

#### **Variables: latitude y longitude**

Los datos de latitud y longitud nos permiten conocer la localización de cada espacio alquilable.
A continuación, imprimimos cada airbnb como un punto sobre un plano básico de distritos de Madrid:

<br/>

```{r mapa, fig.height=7, fig.width=6.5, fig.align="center", message=FALSE, warning=FALSE}
spdf <- geojson_read("../02_Resources/madrid-districts.geojson",  what = "sp")
spdf_fortified <- tidy(spdf)
spdf_df <- as.data.frame(spdf)
sorted_spdf_df <- spdf_df %>% arrange(name)

#Añadimos datos de población al geojson file
sorted_spdf_df$Poblacion_2017 = c(155660, 50010, 260196, 140473, 147551, 140866, 219867, 249973, 193264, 242139, 121683, 95614, 240867, 120406, 147854, 161222, 161313, 142894, 74048, 114512, 154318)

# Gráfico de airbnbs localizadas por latitud y longitud
location <- ggplot(data_train, aes(x=longitude, y=latitude)) + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="grey", color="white", alpha = 0.4) + theme_void() + coord_map() + geom_point(alpha = 0.05, colour="#B03060") + ggtitle('Airbnbs Madrid') + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill= NA, color="white", alpha = 0.1)
location


```

Se aprecia una clara concentración de observaciones en los distritos centrales de Madrid.

<br/>

#### **Variable: neighbourhood_group_cleansed**

El estudio de esta variable es clave para cuantificar la densidad de airbnbs por distrito vista en el mapa del apartado anterior:

```{r distritos, message=FALSE, warning=FALSE, fig.align="center"}
data_train %>%
  group_by(neighbourhood_group_cleansed) %>%
  summarise(count=n()) %>%
  ggplot(aes(x=reorder(neighbourhood_group_cleansed,(count)), y=count, fill = neighbourhood_group_cleansed)) + geom_bar(stat='identity', color = '#262626') + coord_flip() + theme(legend.position = 'none') + ggtitle('Cantidad de Airbnbs por distrito') + ylab('Observaciones') + xlab('Distritos')



#other_districts <- cuentaDistritos %>% slice(-c(1))
#centro_district <- cuentaDistritos %>% slice(c(1))
```

Se comprueba que la densidad de observaciones en el distrito Centro de Madrid es sumamente desproporcionada en comparación con el resto.
Solo en este distrito se acumulan un `r round(count(data_train[data_train$neighbourhood_group_cleansed=="Centro",])*100/nrow(data_train),2)`% de los espacios alquilables de Madrid (casi la mitad).

<br/>

#### **Variables: room type, accomodates, bedrooms y beds**

```{r roomsAccsBeds, message=FALSE, warning=FALSE, fig.align="center"}

data_train %>%
  group_by(room_type) %>%
  summarise(count=n()) %>%
  ggplot(aes(x=reorder(room_type,(-count)), y=count, alpha = room_type)) + geom_bar(stat='identity', col= 'black', fill='#00868B') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none") + xlab('room_type')

cuentaTipos <- data_train %>%
  group_by(room_type) %>%
  summarise(count = n()) %>%
  arrange(-count)

# Tamaño de tablas para el grid
mytheme <- gridExtra::ttheme_default(
    core = list(fg_params=list(cex = 0.5)),
    colhead = list(fg_params=list(cex = 0.5)),
    rowhead = list(fg_params=list(cex = 0.5)))

# Tabla de room types
tbl_types <- gridExtra::tableGrob(cuentaTipos, theme = mytheme)

# Accomodates
ggplot(data_train, aes(x=accommodates)) + geom_histogram(stat='count', col= 'black', fill="palegreen4") +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")

cuentaAccommodates <- data_train %>%
  group_by(accommodates) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_accom <- gridExtra::tableGrob(cuentaAccommodates, theme = mytheme)

# Bedrooms
bedrooms <- ggplot(data_train, aes(x=bedrooms)) + geom_histogram(stat='count', col= 'black', fill="orange3") +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none") + ylim(c(0,9000))

cuentaBedrooms <- data_train %>%
  group_by(bedrooms) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_bedroom <- gridExtra::tableGrob(cuentaBedrooms, theme = mytheme)

# Beds
beds <- ggplot(data_train, aes(x=beds, fill =beds, alpha = beds)) + geom_histogram(stat='count', col= 'black', fill ='#8B0000') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")  + ylim(c(0,9000))

cuentaBeds <- data_train %>%
  group_by(beds) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_bed <- gridExtra::tableGrob(cuentaBeds, theme = mytheme)

# Agrupación de tablas
grid.arrange(bedrooms, beds, ncol=2, nrow =1)
#grid.arrange(tbl_types, tbl_accom, tbl_bed, tbl_bedroom, ncol=4, nrow =1, as.table=TRUE)


```

Tras el análisis de las variables, agrupadas por similitud, concluímos que:

-   Aproximadamente un tercio de las propiedades son para 2 personas, y la gran mayoría son para 6 o menos.
-   Dos tercios de las propiedades tienen 1 dormitorio. La mayoría tiene 5 o menos.
-   La mayoría de las propiedades tienen entre 1 y 4 camas.
-   Existen `r count(data_train[data_train$beds==0,])` propiedades sin cama a pesar de que no existen propiedades sin dormitorios.

<br/>

#### **Variables: min_nights, max_nights, availability_365**

```{r Nights, message=FALSE, warning=FALSE, fig.align="center"}

# Min nights
min_nights <- ggplot(data_train, aes(x=minimum_nights)) + geom_histogram(bindwidth = 5, fill="violetred3", col='white')  + scale_y_continuous(trans='log10') + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMinNights <- data_train %>%
  group_by(minimum_nights) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_min <- tableGrob(head(cuentaMinNights,10), theme = mytheme)

# Min nights average 360 days
min_night_avg <- ggplot(data_train, aes(x=minimum_nights_avg_ntm)) + geom_histogram(bindwidth = 5, fill="#CD853F", col='white')  + scale_y_continuous(trans='log10') + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMinNightsAvg <- data_train %>%
  group_by(minimum_nights_avg_ntm) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_min_avg <- gridExtra::tableGrob(head(cuentaMinNightsAvg,10), theme = mytheme)

# Max nights average 360 days
max_night_avg <- ggplot(data_train, aes(x=maximum_nights_avg_ntm)) + geom_histogram(bindwidth = 5, fill="#40E0D0", col='white')  + scale_y_continuous(trans='log10') + xlim(c(0,2000))  + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMaxNightsAvg <- data_train %>%
  group_by(maximum_nights_avg_ntm) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_max_avg <- gridExtra::tableGrob(head(cuentaMaxNightsAvg,10), theme = mytheme)

# availability_365
avail_360 <- ggplot(data_train, aes(x=availability_365)) + geom_histogram(bindwidth = 5, fill = 'orangered3', col='white')
#sum(data_train$availability_365==0)

# Agrupación de tablas
grid.arrange(min_nights, min_night_avg, max_night_avg, avail_360, ncol=2, nrow =2)
#grid.arrange(tbl_min, tbl_min_avg, tbl_max_avg, ncol=3, nrow =1, as.table=TRUE)
```

Se aprecia una gran similaridad entre las variables $minimum\_nights$ y $minimum\_nights\_avg\_ntm$.
Proseguiremos nuestro análisis con la segunda por tratarse de la media anual, según la definición del diccionario de la base de datos, y descartaremos la primera.

La variable $availability\_365$ muestra que hay alta disponibilidad en los siguientes casos:

-   Un `r round(count(data_train[data_train$availability_365==0,])*100/nrow(data_train),1)`% de los espacios están disponibles en los 10 días posteriores a la fecha de recogida de datos.

-   A 90 y 180 días desde la fecha de recolección de los datos.
    Estas fechas se corresponden con la semana posterior al "Puente de la Constitución" y la semana posterior a los carnavales.

-   La mínima disponibilidad se encuentra entre los días 200 y 220, que se corresponden con la Semana Santa.

-   Entre los 320 y los 350 días, que se corresponden con el mes de Agosto.

-   A los 360 días, que se corresponde con el inicio del mes de Septiembre.

Dado que nuestros datos no contienen la evolución temporal de los precios, la variable $availability\_365$ no aporta gran cantidad de información respecto de los mismos.
Sin embargo, se podría explorar la influencia de la disponibilidad inmediata, sobre la cual se desconoce si es tan numerosa debido a la inmediatez o a la época del año en que los datos fueron recogidos.

<br/>

#### **Variables: Grupo review_scores y reviews_per_month**

```{r ratings, message=FALSE, warning=FALSE, fig.align="center"}

scores <- data_train %>%
  select(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month)


rs_rating <- ggplot(scores, aes(x = review_scores_rating, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#458B74') + xlab("Rating")+ ylab("count")
rs_accuracy <- ggplot(scores, aes(x = review_scores_accuracy, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#8B2323') + xlab("Accuracy")+ ylab("count")
rs_cleanliness <- ggplot(scores, aes(x = review_scores_cleanliness, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'dodgerblue3') + xlab("Cleanliness")+ ylab("count")
rs_checkin <- ggplot(scores, aes(x = review_scores_checkin, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'darkgoldenrod2') + xlab("Check in")+ ylab("count")
rs_communication <- ggplot(scores, aes(x = review_scores_communication, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'darkolivegreen3') + xlab("Communication")+ ylab("count")
rs_location <- ggplot(scores, aes(x = review_scores_location, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#CD5B45')+ xlab("Location")+ ylab("count")
rs_value <- ggplot(scores, aes(x = review_scores_value, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#008B8B')+ xlab("Value")+ ylab("count")
rp_month <- ggplot(scores, aes(x = reviews_per_month, y=..count..)) +
  geom_histogram(binwidth = 0.7, fill = '#CD5555') + xlab("Per month")+ ylab("count")

grid.arrange(rs_rating, rs_accuracy, rs_cleanliness, rs_checkin, rs_communication, rs_location, rs_value, rp_month, ncol=4, nrow =2)
```

Podemos observar que la mayoría de las reviews son positivas, con la mayor concentración de casos entre el 4 y el 5 generalmente.
Todas las variables de puntuación tienen una distribución similar, excepto en el caso de $review\_scores\_value$ y en el de $review\_scores\_rating$ por ser el promedio de todas con la anterior.
Debido a esto, consideramos que únicamente se incluirá en el modelo $review\_scores\_rating$.

$reviews\_per\_month$ indica que la mayoría de espacios tienen pocas o ninguna review al mes.
La representamos más en detalle:

```{r per month, message=FALSE, warning=FALSE, fig.align="center"}
#str(scores$reviews_per_month)
#summary(scores$reviews_per_month)
rpmonth <- na.omit(scores$reviews_per_month)
#summary(rpmonth)

# Creación del layout para diagramas
layout(matrix(c(1,2),2,1, byrow=TRUE), height = c(1,8))

# Boxplot e histograma combinados
par(mar=c(0, 5.1, 1.1, 2.1))
boxplot(rpmonth , horizontal=TRUE, xaxt="n" , col="#FFC125" , frame=F)
par(mar=c(4.5, 5.1, 1.1, 2.1))
hist(rpmonth , breaks=40 , col='#8B3A62' , border=F , main="", ylab="count", xlab="Promedio de reviews/mes", xlim=c(0,8))

```

La mayoria de los espacios en la base de datos, obtienen entre 0 y 2 reviews por mes de media, con más de 4000 personas con una media de 0.25 reviews por mes.
Este resultado tiene sentido, ya que en general las personas suelen estar un par de semanas de vacaciones, y suele haber mayor concetración de turistas en ciertas épocas del año.

```{r scores, fig.height=5.5, fig.width=11, message=FALSE, warning=FALSE}

# head_theme <- gridExtra::ttheme_default(
#     core = list(fg_params=list(cex = 0.6)),
#     colhead = list(fg_params=list(cex = 0.6)),
#     rowhead = list(fg_params=list(cex = 0.6)))
# 
# tbl_scores_head <- gridExtra::tableGrob(head(scores,10), theme = head_theme)
# tbl_scores_summ <- gridExtra::tableGrob(summary(scores), theme = head_theme)
# 
# grid.arrange(tbl_scores_head,tbl_scores_summ, ncol=1, nrow =2, as.table=TRUE)
```

<br/>

#### **Variables: host_since, last_review**

Se ha incluido la variable $host\_since$ para comprobar si existe una correlación entre la experiencia del arrendatario y el precio del espacio.
Su distribución es la siguiente:

```{r host_since, message=FALSE, warning=FALSE, fig.align="center"}

# Host_since
ggplot(data_train, aes(x=host_since)) + geom_histogram(bins = 50, fill="darkslategray", col='white') + theme(legend.position = "none")

```

En nuestro caso, creemos que podríamos sacar más partido a $host\_since$ la convertimos al número de días transcurridos hasta la recolección de los datos $host\_exp\_days$.
De esta forma obtendremos directamente la experiencia del propietario en la plataforma y podremos comprobar si la confianza que genera su antigüedad tiene efecto en el precio.

```{r exp_days, warning=FALSE}
data_train$host_exp_days <- as.integer(max(data_train$host_since, na.rm = TRUE)-data_train$host_since)
data_train$host_since <- NULL
```

```{r last_review, message=FALSE, warning=FALSE, fig.align="center"}

# Host_since
ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 7, col='darkslategray') + theme(legend.position = "none")

```

Este gráfico es muy interesante, puesto que se aprecian claramente dos grupos: aquellos espacios que fueron evaluados por última vez antes de la pandemia del Sars-CoV-2 y aquellos que lo fueron después.

```{r sarsCov2, message=FALSE, warning=FALSE, fig.align="center"}

state_of_alarm <- as.Date("2020-03-15")
days_since_soa <- as.integer(max(data_train$last_review, na.rm = TRUE)-state_of_alarm)

# Plots comparativos de enero a octubre
last_review_2019 <- ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 1, col='darkslategray') + theme(legend.position = "none") + xlim(c(as.Date("2019-01-01"),as.Date("2019-06-01")))
last_review_2020 <- ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 1, col='darkslategray') + theme(legend.position = "none") + xlim(c(as.Date("2020-01-01"),as.Date("2020-06-01"))) + geom_vline(aes(xintercept = state_of_alarm), colour="red")

grid.arrange(last_review_2019, last_review_2020, ncol=2, nrow =1)

# Cálculo de reviews pre- y post estado de alarma



reviewedBeforeCovid <- count(na.omit(data_train[data_train$last_review<state_of_alarm,]))
reviewedAfterCovid <- count(na.omit(data_train[data_train$last_review>state_of_alarm,]))

rBC_pct <- round(100*reviewedBeforeCovid/(reviewedBeforeCovid+reviewedAfterCovid),1)
rAC_pct <- 100-rBC_pct

```

Resulta interesante comprobar el descenso abrupto del número de reviews que se produce el 15 de Marzo de 2020, primer día de Estado de Alarma en España.
Según los datos, el `r rBC_pct`% de los espacios no han recibido una review hasta el día en que se recolectaron los datos (10 de Septiembre).
Podría resultar interesante comparar los precios de los espacios en función de si han sido evaluados antes o después de esta fecha.

Por motivos similares al caso de $host\_since$, se transformará la variable en $last\_review\_days$ utilizando el mismo procedimiento.

```{r last_review_days}
data_train$last_review_days <- as.integer(max(data_train$last_review, na.rm = TRUE)-data_train$last_review)
data_train$last_review <- NULL
```

#### **Variable: host_is_superhost**

$host\_is\_superhost$ es un indicador de excelencia otorgado por la plataforma al arrendatario en base a los siguientes criterios:

-   Rating medio igual o superior a 4.8 durante el último año.

-   Han conseguido más de 10 estancias en el último año o 100 noches durante las 3 últimas estancias.

-   Ratio de cancelación inferior al 1%.

-   Un ratio de respuesta igual o superior al 90%.

<br/>

Creemos que esta variable también podría influir en el precio de los espacios.
La proporción de *superhosts* es la siguiente:

```{r his, message=FALSE, warning=FALSE, fig.align="center"}

# Host is super host
ggplot(na.omit(data_train), aes(x=host_is_superhost, fill =host_is_superhost, alpha = host_is_superhost)) + geom_histogram(stat='count', col= 'black', fill='darkorange3') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")

```

#### Creación de variables nuevas

También nos interesa combinar varias variables para crear otras nuevas que puedan aportar nuevas perspectivas.
Se crearán las siguientes variables:

```{r transforms, warning=FALSE, fig.align="center"}
data_train <- data_train %>%
  add_count(host_id)
colnames(data_train)[colnames(data_train) == 'n'] <- 'host_listings_count'

data_train$price_per_person <- data_train$price/data_train$accommodates

distance <- function(origen, row){
  return(as.numeric(distm(origen, cbind(row$longitude, row$latitude),
                          fun = distHaversine))
  )
}

sol <- c(-3.7035799616333795, 40.417114256598694)

data_train$dist_sol <- distance(sol, data_train)

nuevasVariables <- data.frame("Variable" = c('host_listings_count', 'price_per_person', 'dist_sol'), "Definición" = c("Número de espacios que alquila el dueño","Precio del espacio dividido por el número de plazas ofertadas", "Distancia al centro (Puerta del Sol)"))

nuevasVariables$Tipo <- sapply(data_train[,nuevasVariables$Variable],class)
nuevasVariables <- nuevasVariables[,c(1,3,2)]


kable(nuevasVariables)%>%kable_styling("striped")

```

<br/>

## Estudio e imputación de valores faltantes

```{r data_na, echo=FALSE, message=FALSE, warning=FALSE}

data_train_del_na <- data_train

```

Una vez realizada la copia del conjunto de datos de Training, sobre la cual trabajaremos, se comprueba cuántos valores faltantes tiene cada variable:

```{r grafico_na, echo=FALSE, message=FALSE, warning=FALSE, fig.height=5, fig.width=7.5}

na_vis <- data.frame(t(colSums(is.na(data_train))))
na_bar <- data.frame(Features = names(na_vis),totals=colSums(na_vis))

na_bar %>% ggplot(aes(x = reorder(Features, totals), y = totals, fill = Features, label = totals))+  geom_col() +
  ggtitle("NA Distribution")+
  xlab("Variables")+
  ylab("Total NAs")+
  coord_flip()+
  geom_text(size = 2, position = position_stack(vjust = 0.5))+
  theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position = "none")

```

```{r fig.height=7.5, fig.width=8, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center",eval=FALSE}
md.pattern(data_train, rotate.names=TRUE)

csna <- colSums(is.na(data_train_del_na))
aggr(data_train_del_na, numbers=TRUE, sortVars=TRUE, plot=FALSE)
```

En el caso de *host_is_superhost* y *host_exp_days*, solo tenemos 19 observaciones faltantes, por lo que se optará por reemplazar directamente:

-   NA = false para *host_is_superhost*

-   NA = 0 para *host_exp_days*

<br/>

```{r na min, echo=FALSE, message=FALSE, warning=FALSE}

data_train_del_na$host_is_superhost[which(is.na(data_train_del_na$host_is_superhost))] <- FALSE
data_train_del_na$host_exp_days[which(is.na(data_train_del_na$host_exp_days))] <- 0

```

<br/>

Como el resto de variables tiene una proporción considerable de datos faltantes, se buscará un método para sustituirlos conservando su distribución.

He aquí una matriz de correlación de variables con NA:

```{r cor na, echo=FALSE, message=FALSE, warning=FALSE}
x <- as.data.frame(abs(is.na(data_train_del_na)))
y <- x[, which(colSums(x) > 0)]

kable(cor(y)) %>%
  kable_styling("striped", full_width = F) %>% 
  scroll_box(width = "100%", height = T)
```

```{r datos faltantes train, echo=FALSE, warning=FALSE}



```

<br/>

Para seleccionar un método de sustitución de valores faltantes, primero se analizará qué variables están altamente correlacionadas para excluírlas del proceso, puesto que pueden conducir a una situación de multicolinealidad y, en consecuencia, dificultar su modelado. Aquí se muestran, por pares, aquellas variables que presentan una correlación superior a 0.5:

\

```{r datos high corr, echo=FALSE, message=FALSE, warning=FALSE}

high.corr<-function(x){
  df<-x[sapply(x,is.numeric)]
  fit<-corr.test(df)
  diag(fit$r)<-0
  inds <- which(abs(fit$r) > 0.5, arr.ind=TRUE)

  return(rownames(inds))
}

high.corr(data_train_del_na)

```



<br/>

<br/>

Vemos que existe un nivel relativamente alto de correlación entre las variables *bedrooms* y *accommodates* .

<br/>


#### Imputacion por regresión

<br/>

Intentamos imputar datos faltantes de variable *bedrooms* usando regresion lineal, aprovechando la alta correlación entre esta variable y *accommodates* (`r round(100 * cor(data_train$bedrooms, data_train$accommodates, use="complete.obs"),2)`%).

```{r datos na line,  echo=FALSE, warning=FALSE}
fit <- with(data_train_del_na, lm(bedrooms ~ accommodates))
summary(fit)

```

Vemos que los coeficientes de regresión lineal son significativos, sin embargo, R es lo suficientemente pequeño y explica solo el 47,6% de variación.

<br/>

Veamos en qué se diferencian los valores predichos de los originales:

```{r datos na line result,  echo=FALSE, warning=FALSE}
actuals <- data_train_del_na$bedrooms[!is.na(data_train_del_na$bedrooms)]
pred_lm <- predict(lm( bedrooms ~ accommodates, data = data_train_del_na[!is.na(data_train_del_na$bedrooms), ]))
regr.eval(actuals, pred_lm)
```

El error porcentual absoluto medio (MAPE) fue 26,4%, lo cual es un resultado insatisfactorio. Probaremos otros métodos.

<br/>
<br/>


#### Imputación con paquete **mice**

<br/>

Utilizaremos los métodos *rf* (Random Forest) y *cart* (Classification and Regression Trees) del paquete *mice* para imputar los NA. Esta elección viene dada porque los métodos de imputación predeterminados de *mice* implican regresión lineal. Debido a que existe una alta probabilidad de que una columna sea una combinación lineal de otra, optamos por los métodos antes mencionados.

##### Random Forest:

```{r datos imp rf, echo=FALSE, message=FALSE, warning=FALSE}

miceMod <- mice(data_train_del_na[, !names(data_train_del_na) %in% c("price", "price_per_person", "description")], method="rf", seed = 123)
miceOutput <- complete(miceMod)

```

<br/>

Comparación de las distribuciones de los datos reemplazados con los originales:

```{r datos imp rf graph, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
densityplot(miceMod, xlim = c(2.5, 17.5), ylim = c(0, 0.4))
```

<br/>

##### Classification and Regression Trees:

```{r datos imp cart, echo=FALSE, message=FALSE, warning=FALSE}
miceMod_cart <- mice(data_train_del_na[, !names(data_train_del_na) %in% c("price", "price_per_person", "description")], method="cart", seed = 123)
miceOutput_cart <- complete(miceMod_cart)

```

<br/>




Comparación de las distribuciones de los datos reemplazados con los originales:

```{r datos imp cart graph, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"}
densityplot(miceMod_cart, xlim = c(2.5, 17.5), ylim = c(0, 0.4))
```

<br/>

Podemos apreciar que los datos imputados son muy cercanos a los datos observados, pero el resultado que más se ajusta es por el método *cart*. Usamos este método para imputar los NA de $data\_train$.

```{r datos imputacion, echo=FALSE, message=FALSE, warning=FALSE}
data_train_del_na$bedrooms[which(is.na(data_train_del_na$bedrooms))] <- miceOutput_cart[is.na(data_train_del_na$bedrooms), "bedrooms"]

data_train_del_na$review_scores_rating[which(is.na(data_train_del_na$review_scores_rating))] <- miceOutput_cart[is.na(data_train_del_na$review_scores_rating), "review_scores_rating"]

data_train_del_na$reviews_per_month[which(is.na(data_train_del_na$reviews_per_month))] <- miceOutput_cart[is.na(data_train_del_na$reviews_per_month), "reviews_per_month"]

data_train_del_na$last_review_days[which(is.na(data_train_del_na$last_review_days))] <- miceOutput_cart[is.na(data_train_del_na$last_review_days), "last_review_days"]
```

<br/>

Vamos a comprobar si tras las imputaciones, hemos conseguido reemplazar todos los NAs de las columnas que nis interesan de *data_train* (*bedrooms*, *review_scores_rating*, *reviews_per_month* y *last_review_days*):

```{r datos cart na, echo=FALSE, message=FALSE, warning=FALSE}
na_dat <- colSums(is.na(data_train_del_na)) # False
kable(as.matrix(na_dat[c("bedrooms", "review_scores_rating", "reviews_per_month", "last_review_days")])) %>%
  kable_styling("striped") %>%
  scroll_box(width = "100%", height = TRUE)
```



<!-- Queda confirmada la ausencia de datos faltantes en las variable de interés. -->

```{r}
data_train <- data_train_del_na
```

<br/> <br/>

## Análisis exploratorio multivariante

En esta parte se analizará la relación de la variable objetivo $price$ con el resto de variables seleccionadas.

#### Análisis del precio en función de la localización

```{r precioGeneral, fig.align="center", message=FALSE, warning=FALSE}
# Gráfico de airbnbs localizadas por latitud y longitud, color por precio
adjusted_price <- subset(data_train, price >0 & price < 150)
price_map <- ggplot(adjusted_price, aes(x=longitude, y=latitude, color=price, alpha = 0.2)) + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="grey", color="white", alpha = 0.4) + theme_void() + coord_map() + geom_point() + ggtitle('Airbnbs Madrid') + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill= NA, color="white", alpha = 0.1) + scale_colour_gradient(low = "#8B0A50", high = "#FFA500", na.value = NA)
price_map
```
En este gráfico se puede apreciar cómo la mayoría de espacios de precio superior se encuentran en el distrito Centro, siendo también notoria su presencia en el Bario de Salamanca y en torno al Paseo de la Castellana.



#### Análisis del precio en función del número de plazas

```{r plazas}
# price vs accommodates
pricevsAcco <- data_train %>%
  group_by(accommodates) %>%
  summarise(precio = mean(price))

ggplot(pricevsAcco, aes(x=accommodates, y=precio)) + geom_col(binwidth = 10, color='white', fill='#CD6839') # CHECK: Fairly obvious

# price vs bedrooms
pricevsBR <- data_train %>%
  group_by(bedrooms) %>%
  summarise(precio = mean(price))

price_bedr <- ggplot(pricevsBR, aes(x=bedrooms, y=precio)) + geom_col(binwidth = 10, color='white', fill='#8B2252') # CHECK: accommodates are better

# price vs beds
pricevsBeds <- data_train %>%
  group_by(beds) %>%
  summarise(precio = mean(price))

price_bds <- ggplot(pricevsBeds, aes(x=beds, y=precio)) + geom_col(binwidth = 10, color='white', fill='#698B22') # CHECK: Fairly obvious. Accommodates can be better.


grid.arrange(price_bedr, price_bds, nrow =1, ncol=2)
```

Se comprueba que el precio sube de manera lineal aproximadamente hasta los espacios de 6 plazas. Con los dormitorios y las camas sucede algo similar, pero $accommodates$ nos parece mejor indicativo del precio puesto que desconocemos para cuántas personas son las camas ni cuántas camas tiene cada dormitorio.

Analicemos la distribución de precios por persona:

```{r histPP}
# price vs accommodates
price <- ggplot(data_train, aes(x=price_per_person, y=..density..)) + geom_histogram(binwidth = 10, fill='cadetblue4') + geom_density(alpha = .1, fill="white")

log_price <- ggplot(data_train, aes(x=price_per_person, y=..density..)) + geom_histogram(binwidth = 10, color='white', fill='cadetblue4') + geom_density(alpha = .1, color="#FFA500", fill="white") + xlim(c(0,150)) + ggtitle('Transformación logarítmica')

boxplot_price <- ggplot(data_train, aes(y=price_per_person)) + geom_boxplot(color="#FFA500", fill='cadetblue4') + scale_y_continuous(trans='log10')

quantile_price <- data.frame(quantile(data_train$price_per_person))

colnames(quantile_price) <- c("Observaciones")

tbl <- tableGrob(quantile_price)

grid.arrange(price, log_price,boxplot_price,tbl, ncol=2, nrow =2, as.table=TRUE)
```



En el gráfico podemos ver que la mayoría de pisos se encuentran bajo los 150€ por persona. Para un cuantil de 0.955 tenemos que el precio es de `r round(quantile(data_train$price_per_person, 0.955), 2)`€. El número de observaciones por encima de este valor es `r count(data_train[data_train$price_per_person>quantile(data_train$price_per_person, 0.955),])`, un `r round(count(data_train[data_train$price_per_person>quantile(data_train$price_per_person, 0.955),])*100/nrow(data_train),2)`% de los datos.


Procedemos a eliminar estas observaciones y a recalcular los cuantiles:



```{r cuantilPP}

data_train <- data_train[data_train$price_per_person<quantile(data_train$price_per_person, 0.955),]

boxplot_price <- ggplot(data_train, aes(y=price_per_person)) + geom_boxplot(color="#FFA500", fill='cadetblue4') + scale_y_continuous(trans='log10')

quantile_price <- data.frame(quantile(data_train$price_per_person))

colnames(quantile_price) <- c("Observaciones")

tbl <- tableGrob(quantile_price)

grid.arrange(boxplot_price,tbl, ncol=2, nrow =1, as.table=TRUE)

```



#### Análisis del precio en función de la distancia al centro

```{r mapa precio, fig.align="center", message=FALSE, warning=FALSE}

plot_dist <- ggplot(data_train,aes(x=dist_sol,y=price)) + geom_point() + geom_smooth(method='lm')
plot_distPP <- ggplot(data_train,aes(x=dist_sol,y=price_per_person)) + geom_point() + geom_smooth(method='lm')

grid.arrange(plot_dist,plot_distPP, ncol=2, nrow =1, as.table=TRUE)
```


Se comprueba que el precio disminuye según aumenta la distancia al centro de la ciudad.


#### Análisis del precio en función del distrito

```{r priceVSngc, fig.align="center", message=FALSE, warning=FALSE}

data_train %>%
  ggplot(aes(x=(reorder(neighbourhood_group_cleansed, price, FUN=median)), y=price, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + coord_flip() + theme(legend.position="none") + xlab("Distritos") + ylab("Precio")

```

En la mayoría de casos, el precio se encuentra entre 50 y 100 euros, y apenas hay fluctuación. El caso que llama la atención, es el del distrito de "San Blas - Canillejas": se trata de un barrio alejado del centro, más allá de la M-30. Sus precios, en principio, deberían asemejarse más a los de Ciudad Lineal que a los de Moncloa u Hortaleza.

```{r mapameanCani, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price = mean(price), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price)) + scale_color_gradient(low = "blue", high = "red")

```


```{r countCanillejas, fig.align="center", message=FALSE, warning=FALSE}

dataCan <- data_train[data_train$neighbourhood_group_cleansed=="San Blas - Canillejas",]

ggplot(dataCan, aes(x=room_type, y=price, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("San Blas - Canillejas") + xlab("")

```

Comprobamos que no hay hoteles AirBnb en este distrito, que los precios de las habitaciones privadas se encuentran ligeramente por encima de los apartamentos, y las habitaciones compartidas quintuplican el precio de cualquiera de los anteriores. Esta comparativa no tiene en cuenta el número de personas que pueden utilizar el espacio, por lo que pasamos a representar el precio de cada espacio en función de esta variable:

```{r plCanillejasPP, fig.align="center", message=FALSE, warning=FALSE}

can <- ggplot(dataCan, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("San Blas - Canillejas") + xlab("")
can

```

Este resultado tiene aún menos sentido.


```{r countCanillejasPP, fig.align="center", message=FALSE, warning=FALSE}
count(dataCan %>% group_by(room_type))

```

Como hemos encontrado solo 6 habitaciones compartidas, nos tomaremos un momento para leer sus descripciones:

```{r descrWanda, fig.align="center", fig.height=15, fig.width=6, message=FALSE, warning=FALSE}

dataCan[dataCan$room_type=="Shared room","description"] 

```

Resulta que la palabra "wanda" está incluída en la mayoría. "wanda" se refiere al estadio "Wanda Metropolitano", el estadio del Club Atlético de Madrid, que se encuentra en el límite del distrito. Es plausible que los espacios cercanos al estadio sean alquilados a forofos del Atlético por un precio muy superior al del resto del distrito. Debido a ello, se dividirán los datos del distrito en dos: aquellas observaciones en las que se menciona el estadio y aquellas en las que no.


```{r divWanda, fig.align="center", fig.height=15, fig.width=6, message=FALSE, warning=FALSE}

cercaWanda <- dataCan[grep("wanda|estadio", tolower(dataCan$description)),]
lejosWanda <- anti_join(dataCan, cercaWanda)


cerca_wanda <- ggplot(cercaWanda, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("Cerca del estadio") + xlab("")
lejos_wanda <- ggplot(lejosWanda, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10')  + theme(legend.position="NONE") + ggtitle("Lejos del estadio") + xlab("")

grid.arrange(can, cerca_wanda, lejos_wanda, nrow=3, ncol=1)
```

Se puede concluir que los precios de los espacios compartidos de San Blas - Canillejas cercanos al estadio son superiores a los del resto del distrito. Estos espacios conformarán un nuevo distrito, que denominaremos "Wanda Metropolitano".

<br/>

```{r creaWanda, warning=FALSE}

data_train[rownames(cercaWanda),"neighbourhood_group_cleansed"] <- "Wanda Metropolitano"
data_train[rownames(cercaWanda),"neighbourhood_cleansed"] <- "Wanda Metropolitano"


```

```{r neighNoWanda, message=FALSE, warning=FALSE}

#neighNoWanda <- anti_join(data_train, cercaWanda)

ggplot(data_train, aes(x=reorder(neighbourhood_group_cleansed, price, FUN=median), y=price, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + xlab("neighbourhood_group_cleansed") + coord_flip() + theme(legend.position = "NONE") 

```

```{r neighNoWandaPP, message=FALSE, warning=FALSE}

#neighNoWanda <- anti_join(data_train, cercaWanda)

ggplot(data_train, aes(x=reorder(neighbourhood_group_cleansed, price_per_person, FUN=median), y=price_per_person, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + xlab("neighbourhood_group_cleansed") + coord_flip() + theme(legend.position = "NONE") + ylab("neighbourhood_group_cleansed")

```

El precio medio por distrito queda de la siguiente manera:

```{r mapamean, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price = mean(price), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price)) + scale_color_gradient(low = "blue", high = "red")

```


El precio medio por persona y distrito queda de la siguiente manera:

```{r mapameanPP, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price_per_person = mean(price_per_person), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price_per_person)) + scale_color_gradient(low = "blue", high = "red")

```


<br/>

#### Análisis del precio en función del tipo de habitación

```{r priceVSroomtype, fig.align="center", message=FALSE, warning=FALSE}

# Price vs room type
price_rtyp <- ggplot(data_train, aes(x=room_type, y=price)) + geom_boxplot(outlier.size=0.2, lwd=0.25, color='black', fill='#4F94CD') + scale_y_continuous(trans='log10') + theme(axis.text.x = element_text(size=6, angle = 45, vjust = 0.25, hjust=0.25))
price_rtyp
```

Tiene sentido que los hoteles sean más caros que los apartamentos, estos más caros que las habitaciones privadas, y estas más caras que las compartidas.

```{r pricePPVSroomtype, fig.align="center", message=FALSE, warning=FALSE}

# PricePP vs room type
pricePP_rtyp <- ggplot(data_train, aes(x=room_type, y=price_per_person)) + geom_boxplot(outlier.size=0.2, lwd=0.25, color='black', fill='#4F94CD') + scale_y_continuous(trans='log10') + theme(axis.text.x = element_text(size=6, angle = 45, vjust = 0.25, hjust=0.25))
pricePP_rtyp
```



Si miramos el precio por persona, la relación se mantiene pero en mucha menor medida. Solo destaca el hotel frente al resto.

<br/>
<br/>


#### Análisis del precio en función de la experiencia del host

``` {r shcompare}
#Comparativa ratings con host
ggplot(data_train, aes(x = review_scores_rating, y=..count.., fill = host_is_superhost)) + geom_histogram(binwidth = 0.75, color='black', position='dodge', alpha = 1) + theme(legend.key.size = unit(0.3, 'cm'), legend.title = element_text(size = 6), legend.text = element_text(size = 6))+ xlab("Ratings")+ ylab("count")
```


Vemos que se cumple la definición de **superhost**, teniendo la mayoría de ellos un rating entre 4.5 y 5.



A continuación, vamos a comparar la variable precio con una serie de variables de interés, para ver si relación utilizando técnicas de análisis multivariante y distintos tipos de gráficos.



```{r priceVS, fig.align="center", message=FALSE, warning=FALSE}


# price vs host_since
price_hs <- ggplot(data_train, aes(x=host_exp_days, y=price)) + geom_col(binwidth = 10, fill='#8B1C62') + scale_y_continuous(trans='log') # CHECK: Irrelevant TODO: agregar por promedio 

# price vs host_is_superhost
price_hisph <- ggplot(data_train, aes(x=host_is_superhost, y=price)) + geom_boxplot(outlier.size=0.2, lwd=0.25, color='black', fill='#FFA500') + scale_y_continuous(trans='log10') #CHECK: bit of an edge #FFA500


grid.arrange(price_hs, price_hisph, nrow = 1, ncol=2)
```


En principio no vemos diferencias en los precios según la experiencia del host, ni tampoco se aprecia una diferencia sensible sobre si es o no superhost.

<br/>
<br/>

#### Análisis del precio en función de las reviews


```{r priceReviews}


# reviews_per_month vs price
p <- ggplot(data_train, aes(x=reviews_per_month, y=price, color=price, size=price)) + geom_point() + theme(legend.position="none")
price_rvpm <- ggMarginal(p, type="histogram",lwd=0.2,color='white', fill = "#FFC125", xparams = list(  bins=20),  size=6)

# review_scores_rating vs price
pr <- ggplot(data_train, aes(x=review_scores_rating, y=price, color=price, size=price)) + geom_point() + theme(legend.position="none")
price_rscr <- ggMarginal(pr, type="histogram",lwd=0.2,color='white', fill = "#FFC125", xparams = list(  bins=20),  size=6)

# grids
grid.arrange(price_rscr, price_rvpm, nrow =1, ncol=2)
```


Se observa que en general los espacios con más reviews son los que tienen un precio más alto, y que un mayor rating también podría influír en el precio.


<br/>
<br/>


#### Análisis del precio según fecha de última review

Como se mencionó en el análisis univariante, cabe la posibilidad de que haya un "antes" y un "después" de los precios tras la declaración del Estado de Alarma el 15 de Marzo de 2020:

```{r lastReviewPrice}

data_train <- data_train %>% mutate(precovid = last_review_days<days_since_soa, na.rm=TRUE)

data_train$precovid[which(is.na(data_train$precovid))] <- TRUE # Damos los NA por TRUE, dado que no constan reviews

ggplot(data_train, aes(x=precovid)) + geom_bar(stat='count')

```

```{r precovid}

ggplot(data_train, aes(x=precovid, y = log10(price))) + geom_boxplot()

```


La diferencia de precios en promedio dependiendo de si la propiedad tuvo una review antes o después de la declaración del Estado de Alarma es de `r round(mean(data_train[data_train$precovid==TRUE,"price"]) - mean(data_train[data_train$precovid==FALSE,"price"]),2)`€.

<br/>
<br/>



#### Análisis del precio según disponibilidad y estancia mínima promedio

```{r nights_}

# price vs minimum_nights_avg_ntm
pricevsminimum_nights_avg_ntm <- data_train %>%
  group_by(minimum_nights_avg_ntm) %>%
  summarise(precio = mean(price))

price_minavgn <- ggplot(pricevsminimum_nights_avg_ntm, aes(x=log(minimum_nights_avg_ntm), y=precio)) + geom_col(fill='#FFB90F') + scale_y_continuous(trans='log10') #¿?


# price vs availability_365
pricevsavailability_365 <- data_train %>%
  group_by(availability_365) %>%
  summarise(precio = mean(price))

price_ava365 <- ggplot(pricevsavailability_365, aes(x=availability_365, y=precio)) + geom_col(fill='#8B1A1A') # CHECK: can seasonality be borrowed from here and scraping date?
grid.arrange(price_minavgn, price_ava365, nrow =1, ncol=2)
```


Da la impresión de que estas variables apenas se relacionan con el precio.


<br/>
<br/>


#### Análisis de la variable price, contra las variables ratings y distritos

Preparamos las variables para hacer el ploteado del heatmap. Creamos nuevas variables de mean_ratings y mean_price con la media de cada una de estas variables por distrito, para su comparación con el precio.
Además, añadimos una variable más que no se encuentra en la tabla de datos original: el número de habitantes por distrito en 2017, por pura curiosidad.

```{r basemap, warning=FALSE}


price_dist_rating <- data_train %>% #na.omit(data_train) %>%
  select(review_scores_rating, price, neighbourhood_group_cleansed)

price_dist_rating <- price_dist_rating %>%
  group_by(neighbourhood_group_cleansed) %>%
  summarise (mean_rating = mean(review_scores_rating), mean_price = mean(price))

price_dist_rating <- data.frame(price_dist_rating[price_dist_rating$neighbourhood_group_cleansed!="Wanda Metropolitano",])

head(price_dist_rating, 10)

# Añadimos población del 2017 por distrito
price_dist_rating$Poblacion_2017 = c(155660, 50010, 260196, 140473, 147551, 140866, 219867, 249973, 193264, 242139, 121683, 95614, 240867, 120406, 147854, 161222, 161313, 142894, 74048, 114512, 154318)
pdr_mat <- data.frame(price_dist_rating, row.names = 1)

#write.table(heatmap_df, file = "dataforheatmap.csv",
#            sep = "\t", row.names = F)
```

<br/>

Y a continuación el heatmap de la matriz creada anteriormente

```{r heatmap, fig.align="center", message=FALSE, warning=FALSE}
# Matrix format
mat <- pdr_mat
matriz <- as.matrix(mat)
heatmap(matriz, Colv = NA, Rowv = NA, scale="column", main=NA,cellnote=ifelse(matriz==0, NA, matriz), notecex=0.7,na.color=par("bg"), cexCol=0.7, col= colorRampPalette(brewer.pal(10, "YlOrRd"))(10))
# Heatmap
#d3heatmap(mat, scale="column", dendrogram = "none", width="800px", height="80Opx", colors = "Blues")

#heatmap(matriz, Colv = NA, Rowv = NA, scale="column")
```

El objetivo de este gráfico era realizar un análisis multivariante a tres bandas, cogiendo la variable objetivo y dos de las variables que más nos interesan.
Preliminarmente, esperábamos poder ver una clara relación entre estas variables, pero a nivel visual no hay nada demasiado evidente.
Algo que llama ligeramente la atención es la cierta "simetría" que parece haber entre las columnas de las reviews y la de la población, dónde hay una serie de tonos más oscuros hacia el centro de las columnas.

Es interesante ver también como las medias de reviews más altas, se encuentran en barrios como Vicálvaro, Moratalaz, Monclia, Cuidad Lineal, Fuencarral... y sin embargo zonas como el Centro o Salamanca parecen tener reviews más bajas.

También se puede apreciar muy ligeramente que las zonas dónde hay más población, tienen quizás una menor media de precio, intuyendo que quizás haya menos cantidad de Airbnbs porque hay más población "autóctona".

<br/>



Podemos concluir que aunque no muy evidente, si se aprecia un cierto incremento de color naranja asociado a precios más altos, en los distritos localizados en el centro de la ciudad.

<br/> <br/>




<div class="toxicity-extend-page" data-unique="toxicity-extend-page" style="height:0;">
