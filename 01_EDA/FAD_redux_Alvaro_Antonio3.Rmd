---
title: "FAD Memoria: EDA & LR"
author: "Alvaro Simón Merino, Antonio Fernández Cáceres, Katsiaryna Zaitsava"
date: "15/12/2021"
output:
  html_document: 
    theme:
      bg: "#FFFAFA"
      fg: "#262626"
      primary: "#838B8B"
      secondary: "#333333"
      output_bg: "#999999"
      code_font: 
        google: Open Sans
      base_font:
        google: Source Sans Pro
      heading_font:
        google: Roboto
    code_folding: hide
    toc: yes
    toc_float: yes
    df_printed: paged
    self_contained: true
  pdf_document: 
    theme: united
    code_folding: "hide"
    toc: yes
    toc_float: yes
editor_options: 
  markdown: 
    wrap: sentence
---

------------------------------------------------------------------------

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

[![Haz click para abrir el mapa de Madrid de Airbnb](images/Madrid.jpg "Madrid")](http://insideairbnb.com/madrid/?neighbourhood=&filterEntireHomes=false&filterHighlyAvailable=false&filterRecentReviews=false&filterMultiListings=false)

```{r include, message=FALSE, warning=FALSE}
library(caret)
library(dplyr)
library(ggplot2)
library(stringr)
library(readr)
library(batman)
library(knitr)
library(tidyr)
library(PASWR2)
library(scales)
library(nortest)
library(kableExtra) # sudo apt install libfontconfig1-dev
library(cowplot)
library(mice)
library(VIM)
library(ggcorrplot)
library(psych)
library(ipred)
library(car)
library(geojsonio)
library(gridExtra)
library(shiny)
library(GGally)
library(RColorBrewer)
library(ggExtra)
library(DMwR) # install.packages(c("zoo","xts","quantmod")), luego instala ROCR, luego install.packages( "Path/To/DMwR_0.4.1.tar.gz", repos=NULL, type="source" )
```

<br/> <br/>

## Definición de objetivos

Para la realización de esta práctica se ha seleccionado el dataset *listings.csv* (Airbnb Madrid, 2021-09-10), un conjunto de datos obtenido de [insideairbnb.com](http://insideairbnb.com/).
Puede ser descargado a través de este [enlace](http://data.insideairbnb.com/spain/comunidad-de-madrid/madrid/2021-09-10/data/listings.csv.gz).

El objetivo general de esta práctica es proponer un modelo de regresión lineal multivariante para predecir el precio por noche de un espacio ofertado en la plataforma *AirBnb* y situado en Madrid.
<br/>

Dicho objetivo, a su vez se dividirá en los siguientes pasos:

1.  Selección preliminar de variables.
2.  Separación del conjunto de datos en dos grupos: Training (70% de los datos) y Test (30% de los datos)
3.  Realización de un análisis exploratorio univariante de los datos.
4.  Estudio e imputación de datos faltantes.
5.  Realización de un análisis exploratorio multivariante de los datos.
6.  Transformaciones necesarias a cada una de las variables para poder ser utilizadas en la regresión.
7.  Ajuste, aplicación y evaluación de un modelo de regresión lineal múltiple con las variables seleccionadas para la predicción de la variable $price$.

<br/> <br/>

## Selección preliminar de variables

```{r warning=FALSE, , message=FALSE, include=FALSE}
RawData <- read.csv("../00_DatosOriginales/listings.csv")
```

El conjunto de datos original está formado por un total de `r nrow(RawData)` datos y `r ncol(RawData)` variables, que son:

```{r message=FALSE, warning=FALSE, paged.print=TRUE, echo=FALSE}
col_name <- colnames(RawData)
kable(as.matrix(col_name)) %>%
  kable_styling("striped") %>% 
  scroll_box(width = "100%", height = "350px")
```

<br/>

Basándonos en un conocimiento preliminar proporcionado por la plataforma sobre el contenido de las variables, se seleccionarán aquellas consideradas de potencial interés para la realización del modelo:

```{r datos, message=FALSE, warning=FALSE, paged.print=TRUE}
data <- RawData %>%
   select(id, host_id, host_since, host_is_superhost, description, neighbourhood_group_cleansed, latitude, longitude, property_type, room_type, accommodates, bedrooms, beds, price, minimum_nights, minimum_nights_avg_ntm, maximum_nights_avg_ntm, availability_365, last_review, review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month)

# Corrección de tipos

data$host_since <- as.Date(data$host_since)
data$last_review <- as.Date(data$last_review)

data$host_is_superhost <- as.character(data$host_is_superhost)
data$host_is_superhost[which(data$host_is_superhost == "")] <- NA
data$host_is_superhost[which(data$host_is_superhost == "t")] <- "true"
data$host_is_superhost[which(data$host_is_superhost == "f")] <- "false"
data$host_is_superhost <- to_logical(data$host_is_superhost)

data$price <- as.character(data$price)
data$price<-parse_number(data$price)

data$description <- as.character(data$description)
data$description[which(data$description == "")] <- NA


# Eliminación de observaciones inverosímiles

data <- data[data$price>0 & data$accommodates>0,]


# Selección de variables de interés
   
voi <- data.frame("Variable" = c("host_id", "host_since", "host_is_superhost", "description", "neighbourhood_group_cleansed", "latitude", "longitude", "property_type", "room_type", "accommodates", "bedrooms", "beds", "price", "minimum_nights", "minimum_nights_avg_ntm", "maximum_nights_avg_ntm", "availability_365", "last_review", "review_scores_rating", "review_scores_accuracy", "review_scores_cleanliness", "review_scores_checkin", "review_scores_communication", "review_scores_location", "review_scores_value", "reviews_per_month"),
         
                  "Definición" = c("identificador único de cada arrendador", "fecha en que el arrendador se dio de alta en la plataforma","indicador lógico de si el arrendador tiene excelentes puntuaciones","descripción del espacio alquilable","distrito en que se encuentra el espacio alquilable","coordenada de latitud del espacio alquilable","coordenada de longitud del espacio alquilable","tipo de propiedad","tipo de habitación","capacidad máxima del espacio","número de cuartos de baño","número de camas de la habitación","precio por noche en moneda local","mínimo de noches por estancia","promedio de mínimo de noches durante los próximos 365 días","promedio de máximo de noches durante los próximos 365 días","disponibilidad del espacio durante los próximos 365 días","fecha de la última puntuación","puntuación general del espacio","puntuación sobre la realidad/descripción del espacio","puntuación sobre la limpieza del espacio","puntuación sobre el checkin","puntuación sobre lo bien que está comunicado el espacio","puntuación de la localización del espacio","puntuación del valor del espacio","media de número de reviews por espacio durante un mes"))

voi$Tipo <- sapply(data[,voi$Variable],class)
voi <- voi[,c(1,3,2)]

kable(voi) %>% kable_styling("striped") %>%
  scroll_box(width = "100%", height = "350px")

```

Aunque se intuye antes de comenzar que hay variables que van a aportar poca información o son similares a otras o combinaciones de varias, de momento se conservarán cara a realizar un análisis previo para justificar su inclusión o exclusión de nuestro estudio.

<br/>

## Separación del conjunto de datos en dos grupos

Se procede a dividir el conjunto de datos en dos partes: el 70% para grupo de Training y 30% para grupo de Test.
No se considera necesario un muestreo estratificado debido a que el número de observaciones es grande.
Se hará de manera pseudoaleatoria:

```{r slice, message=FALSE, warning=FALSE}
set.seed(12345)
inTraining <- createDataPartition(pull(RawData, neighbourhood_group_cleansed),
                                  p = .7, list = FALSE, times = 1)
data_train <- slice(data, inTraining)
data_test <- slice(data, -inTraining)

groups <- data.frame("Grupos" = c("Training","Test"), "Observaciones" = c(nrow(data_train),nrow(data_test)), "Porcentaje" = c(round(nrow(data_train)*100/nrow(data),1),round(nrow(data_test)*100/nrow(data),1)))

kable(groups) %>% kable_styling("striped")
```

<br/>

A partir de ahora, y hasta que se ponga a prueba el modelo, se utilizarán exclusivamente los datos del grupo de Training.

<br/> <br/>

## Análisis exploratorio univariante

<br/>

#### **Variable objetivo: price**

La variable $price$, la cual queremos predecir, en general se concentra entre los 37 y los 105€, y en general el número de Airbnbs decrece con el precio:

```{r precios, message=FALSE, warning=FALSE, fig.align="center"}
price <- ggplot(data_train, aes(x=price, y=..density..)) + geom_histogram(binwidth = 10, fill='cadetblue4') + geom_density(alpha = .1, fill="white")

log_price <- ggplot(data_train, aes(x=price, y=..density..)) + geom_histogram(binwidth = 10, color='white', fill='cadetblue4') + geom_density(alpha = .1, color="#FFA500", fill="white") + xlim(c(0,500)) + ggtitle('Transformación logarítmica')

boxplot_price <- ggplot(data_train, aes(y=price)) + geom_boxplot(color="#FFA500", fill='cadetblue4') + scale_y_continuous(trans='log10')

quantile_price <- data.frame(quantile(data_train$price))

colnames(quantile_price) <- c("Observaciones")

tbl <- tableGrob(quantile_price)

grid.arrange(price, log_price,boxplot_price,tbl, ncol=2, nrow =2, as.table=TRUE)
```

El precio medio por noche es de `r round(mean(data$price),2)` €.
El precio mínimo es `r min(data$price)`€, y el precio máximo es de `r max(data$price)`€.
Se ha comprobado accediendo a la plataforma que valores tan altos no tienen por qué ser erróneos.
Sin embargo, se observa que la distribución posee una cola muy larga en su lado derecho, lo cual puede dar problemas a la hora de realizar la regresión.

<br/>

#### **Variables: latitude y longitude**

Los datos de latitud y longitud nos permiten conocer la localización de cada espacio alquilable.
A continuación, imprimimos cada airbnb como un punto sobre un plano básico de distritos de Madrid:

<br/>

```{r mapa, fig.height=7, fig.width=6.5, fig.align="center", message=FALSE, warning=FALSE}
spdf <- geojson_read("../02_Resources/madrid-districts.geojson",  what = "sp")
spdf_fortified <- tidy(spdf)
spdf_df <- as.data.frame(spdf)
sorted_spdf_df <- spdf_df %>% arrange(name)

#Añadimos datos de población al geojson file
sorted_spdf_df$Poblacion_2017 = c(155660, 50010, 260196, 140473, 147551, 140866, 219867, 249973, 193264, 242139, 121683, 95614, 240867, 120406, 147854, 161222, 161313, 142894, 74048, 114512, 154318)

# Gráfico de airbnbs localizadas por latitud y longitud
location <- ggplot(data_train, aes(x=longitude, y=latitude)) + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="grey", color="white", alpha = 0.4) + theme_void() + coord_map() + geom_point(alpha = 0.05, colour="#B03060") + ggtitle('Airbnbs Madrid') + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill= NA, color="white", alpha = 0.1)
location


```

Se aprecia una clara concentración de observaciones en los distritos centrales de Madrid.

<br/>

#### **Variable: neighbourhood_group_cleansed**

El estudio de esta variable es clave para cuantificar la densidad de airbnbs por distrito vista en el mapa del apartado anterior:

```{r distritos, message=FALSE, warning=FALSE, fig.align="center"}
data_train %>%
  group_by(neighbourhood_group_cleansed) %>%
  summarise(count=n()) %>%
  ggplot(aes(x=reorder(neighbourhood_group_cleansed,(count)), y=count, fill = neighbourhood_group_cleansed)) + geom_bar(stat='identity', color = '#262626') + coord_flip() + theme(legend.position = 'none') + ggtitle('Cantidad de Airbnbs por distrito') + ylab('Observaciones') + xlab('Distritos')



#other_districts <- cuentaDistritos %>% slice(-c(1))
#centro_district <- cuentaDistritos %>% slice(c(1))
```

Se comprueba que la densidad de observaciones en el distrito Centro de Madrid es sumamente desproporcionada en comparación con el resto.
Solo en este distrito se acumulan un `r round(count(data_train[data_train$neighbourhood_group_cleansed=="Centro",])*100/nrow(data_train),2)`% de los espacios alquilables de Madrid (casi la mitad).

<br/>

#### **Variables: room type, accomodates, bedrooms y beds**

```{r roomsAccsBeds, message=FALSE, warning=FALSE, fig.align="center"}

data_train %>%
  group_by(room_type) %>%
  summarise(count=n()) %>%
  ggplot(aes(x=reorder(room_type,(-count)), y=count, alpha = room_type)) + geom_bar(stat='identity', col= 'black', fill='#00868B') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none") + xlab('room_type')

cuentaTipos <- data_train %>%
  group_by(room_type) %>%
  summarise(count = n()) %>%
  arrange(-count)

# Tamaño de tablas para el grid
mytheme <- gridExtra::ttheme_default(
    core = list(fg_params=list(cex = 0.5)),
    colhead = list(fg_params=list(cex = 0.5)),
    rowhead = list(fg_params=list(cex = 0.5)))

# Tabla de room types
tbl_types <- gridExtra::tableGrob(cuentaTipos, theme = mytheme)

# Accomodates
ggplot(data_train, aes(x=accommodates)) + geom_histogram(stat='count', col= 'black', fill="palegreen4") +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")

cuentaAccommodates <- data_train %>%
  group_by(accommodates) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_accom <- gridExtra::tableGrob(cuentaAccommodates, theme = mytheme)

# Bedrooms
bedrooms <- ggplot(data_train, aes(x=bedrooms)) + geom_histogram(stat='count', col= 'black', fill="orange3") +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none") + ylim(c(0,9000))

cuentaBedrooms <- data_train %>%
  group_by(bedrooms) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_bedroom <- gridExtra::tableGrob(cuentaBedrooms, theme = mytheme)

# Beds
beds <- ggplot(data_train, aes(x=beds, fill =beds, alpha = beds)) + geom_histogram(stat='count', col= 'black', fill ='#8B0000') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")  + ylim(c(0,9000))

cuentaBeds <- data_train %>%
  group_by(beds) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_bed <- gridExtra::tableGrob(cuentaBeds, theme = mytheme)

# Agrupación de tablas
grid.arrange(bedrooms, beds, ncol=2, nrow =1)
#grid.arrange(tbl_types, tbl_accom, tbl_bed, tbl_bedroom, ncol=4, nrow =1, as.table=TRUE)


```

Tras el análisis de las variables, agrupadas por similitud, concluímos que:

-   Aproximadamente un tercio de las propiedades son para 2 personas, y la gran mayoría son para 6 o menos.
-   Dos tercios de las propiedades tienen 1 dormitorio. La mayoría tiene 5 o menos.
-   La mayoría de las propiedades tienen entre 1 y 4 camas.
-   Existen `r count(data_train[data_train$beds==0,])` propiedades sin cama a pesar de que no existen propiedades sin dormitorios.

<br/>

#### **Variables: min_nights, max_nights, availability_365**

```{r Nights, message=FALSE, warning=FALSE, fig.align="center"}

# Min nights
min_nights <- ggplot(data_train, aes(x=minimum_nights)) + geom_histogram(bindwidth = 5, fill="violetred3", col='white')  + scale_y_continuous(trans='log10') + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMinNights <- data_train %>%
  group_by(minimum_nights) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_min <- tableGrob(head(cuentaMinNights,10), theme = mytheme)

# Min nights average 360 days
min_night_avg <- ggplot(data_train, aes(x=minimum_nights_avg_ntm)) + geom_histogram(bindwidth = 5, fill="#CD853F", col='white')  + scale_y_continuous(trans='log10') + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMinNightsAvg <- data_train %>%
  group_by(minimum_nights_avg_ntm) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_min_avg <- gridExtra::tableGrob(head(cuentaMinNightsAvg,10), theme = mytheme)

# Max nights average 360 days
max_night_avg <- ggplot(data_train, aes(x=maximum_nights_avg_ntm)) + geom_histogram(bindwidth = 5, fill="#40E0D0", col='white')  + scale_y_continuous(trans='log10') + xlim(c(0,2000))  + scale_x_continuous(limits = c(0, 400)) + theme(legend.position = "none")

cuentaMaxNightsAvg <- data_train %>%
  group_by(maximum_nights_avg_ntm) %>%
  summarise(count = n()) %>%
  arrange(-count)

tbl_max_avg <- gridExtra::tableGrob(head(cuentaMaxNightsAvg,10), theme = mytheme)

# availability_365
avail_360 <- ggplot(data_train, aes(x=availability_365)) + geom_histogram(bindwidth = 5, fill = 'orangered3', col='white')
#sum(data_train$availability_365==0)

# Agrupación de tablas
grid.arrange(min_nights, min_night_avg, max_night_avg, avail_360, ncol=2, nrow =2)
#grid.arrange(tbl_min, tbl_min_avg, tbl_max_avg, ncol=3, nrow =1, as.table=TRUE)
```

Se aprecia una gran similaridad entre las variables $minimum\_nights$ y $minimum\_nights\_avg\_ntm$.
Proseguiremos nuestro análisis con la segunda por tratarse de la media anual, según la definición del diccionario de la base de datos, y descartaremos la primera.

La variable $availability\_365$ muestra que hay alta disponibilidad en los siguientes casos:

-   Un `r round(count(data_train[data_train$availability_365==0,])*100/nrow(data_train),1)`% de los espacios están disponibles en los 10 días posteriores a la fecha de recogida de datos.

-   A 90 y 180 días desde la fecha de recolección de los datos.
    Estas fechas se corresponden con la semana posterior al "Puente de la Constitución" y la semana posterior a los carnavales.

-   La mínima disponibilidad se encuentra entre los días 200 y 220, que se corresponden con la Semana Santa.

-   Entre los 320 y los 350 días, que se corresponden con el mes de Agosto.

-   A los 360 días, que se corresponde con el inicio del mes de Septiembre.

Dado que nuestros datos no contienen la evolución temporal de los precios, la variable $availability\_365$ no aporta gran cantidad de información respecto de los mismos.
Sin embargo, se podría explorar la influencia de la disponibilidad inmediata, sobre la cual se desconoce si es tan numerosa debido a la inmediatez o a la época del año en que los datos fueron recogidos.

<br/>

#### **Variables: Grupo review_scores y reviews_per_month**

```{r ratings, message=FALSE, warning=FALSE, fig.align="center"}

scores <- data_train %>%
  select(review_scores_rating, review_scores_accuracy, review_scores_cleanliness, review_scores_checkin, review_scores_communication, review_scores_location, review_scores_value, reviews_per_month)


rs_rating <- ggplot(scores, aes(x = review_scores_rating, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#458B74') + xlab("Rating")+ ylab("count")
rs_accuracy <- ggplot(scores, aes(x = review_scores_accuracy, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#8B2323') + xlab("Accuracy")+ ylab("count")
rs_cleanliness <- ggplot(scores, aes(x = review_scores_cleanliness, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'dodgerblue3') + xlab("Cleanliness")+ ylab("count")
rs_checkin <- ggplot(scores, aes(x = review_scores_checkin, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'darkgoldenrod2') + xlab("Check in")+ ylab("count")
rs_communication <- ggplot(scores, aes(x = review_scores_communication, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = 'darkolivegreen3') + xlab("Communication")+ ylab("count")
rs_location <- ggplot(scores, aes(x = review_scores_location, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#CD5B45')+ xlab("Location")+ ylab("count")
rs_value <- ggplot(scores, aes(x = review_scores_value, y=..count..)) +
  geom_histogram(binwidth = 0.5, color='black', fill = '#008B8B')+ xlab("Value")+ ylab("count")
rp_month <- ggplot(scores, aes(x = reviews_per_month, y=..count..)) +
  geom_histogram(binwidth = 0.7, fill = '#CD5555') + xlab("Per month")+ ylab("count")

grid.arrange(rs_rating, rs_accuracy, rs_cleanliness, rs_checkin, rs_communication, rs_location, rs_value, rp_month, ncol=4, nrow =2)
```

Podemos observar que la mayoría de las reviews son positivas, con la mayor concentración de casos entre el 4 y el 5 generalmente.
Todas las variables de puntuación tienen una distribución similar, excepto en el caso de $review\_scores\_value$ y en el de $review\_scores\_rating$ por ser el promedio de todas con la anterior.
Debido a esto, consideramos que únicamente se incluirá en el modelo $review\_scores\_rating$.

$reviews\_per\_month$ indica que la mayoría de espacios tienen pocas o ninguna review al mes.
La representamos más en detalle:

```{r per month, message=FALSE, warning=FALSE, fig.align="center"}
#str(scores$reviews_per_month)
#summary(scores$reviews_per_month)
rpmonth <- na.omit(scores$reviews_per_month)
#summary(rpmonth)

# Creación del layout para diagramas
layout(matrix(c(1,2),2,1, byrow=TRUE), height = c(1,8))

# Boxplot e histograma combinados
par(mar=c(0, 5.1, 1.1, 2.1))
boxplot(rpmonth , horizontal=TRUE, xaxt="n" , col="#FFC125" , frame=F)
par(mar=c(4.5, 5.1, 1.1, 2.1))
hist(rpmonth , breaks=40 , col='#8B3A62' , border=F , main="", ylab="count", xlab="Promedio de reviews/mes", xlim=c(0,8))

```

La mayoria de los espacios en la base de datos, obtienen entre 0 y 2 reviews por mes de media, con más de 4000 personas con una media de 0.25 reviews por mes.
Este resultado tiene sentido, ya que en general las personas suelen estar un par de semanas de vacaciones, y suele haber mayor concetración de turistas en ciertas épocas del año.

```{r scores, fig.height=5.5, fig.width=11, message=FALSE, warning=FALSE}

# head_theme <- gridExtra::ttheme_default(
#     core = list(fg_params=list(cex = 0.6)),
#     colhead = list(fg_params=list(cex = 0.6)),
#     rowhead = list(fg_params=list(cex = 0.6)))
# 
# tbl_scores_head <- gridExtra::tableGrob(head(scores,10), theme = head_theme)
# tbl_scores_summ <- gridExtra::tableGrob(summary(scores), theme = head_theme)
# 
# grid.arrange(tbl_scores_head,tbl_scores_summ, ncol=1, nrow =2, as.table=TRUE)
```

<br/>

#### **Variables: host_since, last_review**

Se ha incluido la variable $host\_since$ para comprobar si existe una correlación entre la experiencia del arrendatario y el precio del espacio.
Su distribución es la siguiente:

```{r host_since, message=FALSE, warning=FALSE, fig.align="center"}

# Host_since
ggplot(data_train, aes(x=host_since)) + geom_histogram(bins = 50, fill="darkslategray", col='white') + theme(legend.position = "none")

```

En nuestro caso, creemos que podríamos sacar más partido a $host\_since$ la convertimos al número de días transcurridos hasta la recolección de los datos $host\_exp\_days$.
De esta forma obtendremos directamente la experiencia del propietario en la plataforma y podremos comprobar si la confianza que genera su antigüedad tiene efecto en el precio.

```{r exp_days, warning=FALSE}
data_train$host_exp_days <- as.integer(max(data_train$host_since, na.rm = TRUE)-data_train$host_since)
data_train$host_since <- NULL
```

```{r last_review, message=FALSE, warning=FALSE, fig.align="center"}

# Host_since
ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 7, col='darkslategray') + theme(legend.position = "none")

```

Este gráfico es muy interesante, puesto que se aprecian claramente dos grupos: aquellos espacios que fueron evaluados por última vez antes de la pandemia del Sars-CoV-2 y aquellos que lo fueron después.

```{r sarsCov2, message=FALSE, warning=FALSE, fig.align="center"}

state_of_alarm <- as.Date("2020-03-15")

# Plots comparativos de enero a octubre
last_review_2019 <- ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 1, col='darkslategray') + theme(legend.position = "none") + xlim(c(as.Date("2019-01-01"),as.Date("2019-06-01")))
last_review_2020 <- ggplot(data_train, aes(x=last_review)) + geom_histogram(binwidth = 1, col='darkslategray') + theme(legend.position = "none") + xlim(c(as.Date("2020-01-01"),as.Date("2020-06-01"))) + geom_vline(aes(xintercept = state_of_alarm), colour="red")

grid.arrange(last_review_2019, last_review_2020, ncol=2, nrow =1)

# Cálculo de reviews pre- y post estado de alarma



reviewedBeforeCovid <- count(na.omit(data_train[data_train$last_review<state_of_alarm,]))
reviewedAfterCovid <- count(na.omit(data_train[data_train$last_review>state_of_alarm,]))

rBC_pct <- round(100*reviewedBeforeCovid/(reviewedBeforeCovid+reviewedAfterCovid),1)
rAC_pct <- 100-rBC_pct

```

Resulta interesante comprobar el descenso abrupto del número de reviews que se produce el 15 de Marzo de 2020, primer día de Estado de Alarma en España.
Según los datos, el `r rBC_pct`% de los espacios no han recibido una review hasta el día en que se recolectaron los datos (10 de Septiembre).
Podría resultar interesante comparar los precios de los espacios en función de si han sido evaluados antes o después de esta fecha.

Por motivos similares al caso de $host\_since$, se transformará la variable en $last\_review\_days$ utilizando el mismo procedimiento.

```{r last_review_days}
data_train$last_review_days <- as.integer(max(data_train$last_review, na.rm = TRUE)-data_train$last_review)
data_train$last_review <- NULL
```

#### **Variable: host_is_superhost**

$host\_is\_superhost$ es un indicador de excelencia otorgado por la plataforma al arrendatario en base a los siguientes criterios:

-   Rating medio igual o superior a 4.8 durante el último año.

-   Han conseguido más de 10 estancias en el último año o 100 noches durante las 3 últimas estancias.

-   Ratio de cancelación inferior al 1%.

-   Un ratio de respuesta igual o superior al 90%.

<br/>

Creemos que esta variable también podría influir en el precio de los espacios.
La proporción de *superhosts* es la siguiente:

```{r his, message=FALSE, warning=FALSE, fig.align="center"}

# Host is super host
ggplot(na.omit(data_train), aes(x=host_is_superhost, fill =host_is_superhost, alpha = host_is_superhost)) + geom_histogram(stat='count', col= 'black', fill='darkorange3') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")

```

#### Creación de variables nuevas

También nos interesa combinar varias variables para crear otras nuevas que puedan aportar nuevas perspectivas.
Se crearán las siguientes variables:

```{r transforms, warning=FALSE, fig.align="center"}
data_train <- data_train %>%
  add_count(host_id)
colnames(data_train)[colnames(data_train) == 'n'] <- 'host_listings_count'

data_train$price_per_person <- data_train$price/data_train$accommodates

nuevasVariables <- data.frame("Variable" = c('host_listings_count', 'price_per_person'), "Definición" = c("Número de espacios que alquila el dueño","Precio del espacio dividido por el número de plazas ofertadas"))

nuevasVariables$Tipo <- sapply(data_train[,nuevasVariables$Variable],class)
nuevasVariables <- nuevasVariables[,c(1,3,2)]

kable(nuevasVariables)%>%kable_styling("striped")

```

<br/>

## Estudio e imputación de valores faltantes

```{r data_na, echo=FALSE, message=FALSE, warning=FALSE}

data_train_del_na <- data_train

```

Una vez realizada la copia del conjunto de datos de Training, sobre la cual trabajaremos, se comprueba cuántos valores faltantes tiene cada variable:

```{r grafico_na, echo=FALSE, message=FALSE, warning=FALSE, fig.height=5, fig.width=7.5}

na_vis <- data.frame(t(colSums(is.na(data_train))))
na_bar <- data.frame(Features = names(na_vis),totals=colSums(na_vis))

na_bar %>% ggplot(aes(x = reorder(Features, totals), y = totals, fill = Features, label = totals))+  geom_col() +
  ggtitle("NA Distribution")+
  xlab("Variables")+
  ylab("Total NAs")+
  coord_flip()+
  geom_text(size = 2, position = position_stack(vjust = 0.5))+
  theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position = "none")

```

```{r fig.height=7.5, fig.width=8, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center",eval=FALSE}
md.pattern(data_train, rotate.names=TRUE)

csna <- colSums(is.na(data_train_del_na))
aggr(data_train_del_na, numbers=TRUE, sortVars=TRUE, plot=FALSE)
```

En el caso de *host_is_superhost* y *host_exp_days*, solo tenemos 19 observaciones faltantes, por lo que se optará por reemplazar directamente:

-   NA = false para *host_is_superhost*

-   NA = 0 para *host_exp_days*

<br/>

```{r na min, echo=FALSE, message=FALSE, warning=FALSE}

data_train_del_na$host_is_superhost[which(is.na(data_train_del_na$host_is_superhost))] <- FALSE
data_train_del_na$host_exp_days[which(is.na(data_train_del_na$host_exp_days))] <- 0

```

<br/>

Como el resto de variables tiene una proporción considerable de datos faltantes, se buscará un método para sustituirlos conservando su distribución.

He aquí una matriz de correlación de variables con NA:

```{r cor na, echo=FALSE, message=FALSE, warning=FALSE}
x <- as.data.frame(abs(is.na(data_train_del_na)))
y <- x[, which(colSums(x) > 0)]

kable(cor(y)) %>%
  kable_styling("striped", full_width = F) %>% 
  scroll_box(width = "100%", height = T)
```

```{r datos faltantes train, echo=FALSE, warning=FALSE}



```

<br/>

Para seleccionar un método de sustitución de valores faltantes, primero se analizará qué variables están altamente correlacionadas para excluírlas del proceso, puesto que pueden conducir a una situación de multicolinealidad y, en consecuencia, dificultar su modelado. Aquí se muestran, por pares, aquellas variables que presentan una correlación superior a 0.5:

\

```{r datos high corr, echo=FALSE, message=FALSE, warning=FALSE}

high.corr<-function(x){
  df<-x[sapply(x,is.numeric)]
  fit<-corr.test(df)
  diag(fit$r)<-0
  inds <- which(abs(fit$r) > 0.5, arr.ind=TRUE)

  return(rownames(inds))
}

high.corr(data_train_del_na)

```



<br/>

<br/>

Vemos que existe un nivel relativamente alto de correlación entre las variables *bedrooms* y *accommodates* .

<br/>


#### Imputacion por regresión

<br/>

Intentamos imputar datos faltantes de variable *bedrooms* usando regresion lineal, aprovechando la alta correlación entre esta variable y *accommodates* (`r round(100 * cor(data_train$bedrooms, data_train$accommodates, use="complete.obs"),2)`%).

```{r datos na line,  echo=FALSE, warning=FALSE}
fit <- with(data_train_del_na, lm(bedrooms ~ accommodates))
summary(fit)

```

Vemos que los coeficientes de regresión lineal son significativos, sin embargo, R es lo suficientemente pequeño y explica solo el 47,6% de variación.

<br/>

Veamos en qué se diferencian los valores predichos de los originales:

```{r datos na line result,  echo=FALSE, warning=FALSE}
actuals <- data_train_del_na$bedrooms[!is.na(data_train_del_na$bedrooms)]
pred_lm <- predict(lm( bedrooms ~ accommodates, data = data_train_del_na[!is.na(data_train_del_na$bedrooms), ]))
regr.eval(actuals, pred_lm)
```

El error porcentual absoluto medio (MAPE) fue 26,4%, lo cual es un resultado insatisfactorio. Probaremos otros métodos.

<br/>
<br/>


<!-- #### Imputación con paquete **mice** -->

<!-- <br/> -->

<!-- Utilizaremos los métodos *rf* (Random Forest) y *cart* (Classification and Regression Trees) del paquete *mice* para imputar los NA. Esta elección viene dada porque los métodos de imputación predeterminados de *mice* implican regresión lineal. Debido a que existe una alta probabilidad de que una columna sea una combinación lineal de otra, optamos por los métodos antes mencionados. -->

<!-- ##### Random Forest: -->

<!-- ```{r datos imp rf, echo=FALSE, message=FALSE, warning=FALSE} -->

<!-- miceMod <- mice(data_train_del_na[, !names(data_train_del_na) %in% c("price", "price_per_person", "description")], method="rf", seed = 123) -->
<!-- miceOutput <- complete(miceMod) -->

<!-- ``` -->

<!-- <br/> -->

<!-- Comparación de las distribuciones de los datos reemplazados con los originales: -->

<!-- ```{r datos imp rf graph, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"} -->
<!-- densityplot(miceMod, xlim = c(2.5, 17.5), ylim = c(0, 0.4)) -->
<!-- ``` -->

<!-- <br/> -->

<!-- ##### Classification and Regression Trees: -->

<!-- ```{r datos imp cart, echo=FALSE, message=FALSE, warning=FALSE} -->
<!-- miceMod_cart <- mice(data_train_del_na[, !names(data_train_del_na) %in% c("price", "price_per_person", "description")], method="cart", seed = 123) -->
<!-- miceOutput_cart <- complete(miceMod_cart) -->

<!-- ``` -->

<!-- <br/> -->




<!-- Comparación de las distribuciones de los datos reemplazados con los originales: -->

<!-- ```{r datos imp cart graph, echo=FALSE, message=FALSE, warning=FALSE, fig.align="center"} -->
<!-- densityplot(miceMod_cart, xlim = c(2.5, 17.5), ylim = c(0, 0.4)) -->
<!-- ``` -->

<!-- <br/> -->

<!-- Podemos apreciar que los datos imputados son muy cercanos a los datos observados, pero el resultado que más se ajusta es por el método *cart*. Usamos este método para imputar los NA de $data\_train$. -->

<!-- ```{r datos imputacion, echo=FALSE, message=FALSE, warning=FALSE} -->
<!-- data_train_del_na$bedrooms[which(is.na(data_train_del_na$bedrooms))] <- miceOutput_cart[is.na(data_train_del_na$bedrooms), "bedrooms"] -->

<!-- data_train_del_na$review_scores_rating[which(is.na(data_train_del_na$review_scores_rating))] <- miceOutput_cart[is.na(data_train_del_na$review_scores_rating), "review_scores_rating"] -->

<!-- data_train_del_na$reviews_per_month[which(is.na(data_train_del_na$reviews_per_month))] <- miceOutput_cart[is.na(data_train_del_na$reviews_per_month), "reviews_per_month"] -->

<!-- data_train_del_na$last_review_days[which(is.na(data_train_del_na$last_review_days))] <- miceOutput_cart[is.na(data_train_del_na$last_review_days), "last_review_days"] -->
<!-- ``` -->

<!-- <br/> -->

<!-- Vamos a comprobar si tras las imputaciones, hemos conseguido reemplazar todos los NAs de las columnas que nis interesan de *data_train* (*bedrooms*, *review_scores_rating*, *reviews_per_month* y *last_review_days*): -->

<!-- ```{r datos cart na, echo=FALSE, message=FALSE, warning=FALSE} -->
<!-- na_dat <- colSums(is.na(data_train_del_na)) # False -->
<!-- kable(as.matrix(na_dat[c("bedrooms", "review_scores_rating", "reviews_per_month", "last_review_days")])) %>% -->
<!--   kable_styling("striped") %>% -->
<!--   scroll_box(width = "100%", height = TRUE) -->
<!-- ``` -->



<!-- Queda confirmada la ausencia de datos faltantes en las variable de interés. -->

<!-- ```{r} -->
<!-- data_train <- data_train_del_na -->
<!-- ``` -->

<br/> <br/>

## Análisis exploratorio multivariante

En esta parte se analizará la relación de la variable objetivo $price$ con el resto de variables seleccionadas.

#### Análisis del precio en función de la localización

```{r mapa precio, fig.align="center", message=FALSE, warning=FALSE}
# Gráfico de airbnbs localizadas por latitud y longitud, color por precio
adjusted_price <- subset(data_train, price >0 & price < 150)
price_map <- ggplot(adjusted_price, aes(x=longitude, y=latitude, color=price, alpha = 0.2)) + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill="grey", color="white", alpha = 0.4) + theme_void() + coord_map() + geom_point() + ggtitle('Airbnbs Madrid') + geom_polygon(data = spdf_fortified, aes( x = long, y = lat, group = group), fill= NA, color="white", alpha = 0.1) + scale_colour_gradient(low = "#8B0A50", high = "#FFA500", na.value = NA)
price_map
```
En este gráfico se puede apreciar cómo la mayoría de espacios de precio superior se encuentran en el distrito Centro, siendo también notoria su presencia en el Bario de Salamanca y en torno al Paseo de la Castellana.


#### Análisis del precio en función del distrito

```{r priceVSngc, fig.align="center", message=FALSE, warning=FALSE}

data_train %>%
  ggplot(aes(x=(reorder(neighbourhood_group_cleansed, price, FUN=median)), y=price, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + coord_flip() + theme(legend.position="none") + xlab("Distritos") + ylab("Precio")

```

En la mayoría de casos, el precio se encuentra entre 50 y 100 euros, y apenas hay fluctuación. El caso que llama la atención, es el del distrito de "San Blas - Canillejas": se trata de un barrio alejado del centro, más allá de la M-30. Sus precios, en principio, deberían asemejarse más a los de Ciudad Lineal que a los de el barrio de Salamanca o el Centro.

```{r mapameanCani, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price = mean(price), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price)) + scale_color_gradient(low = "blue", high = "red")

```


```{r countCanillejas, fig.align="center", message=FALSE, warning=FALSE}

dataCan <- data_train[data_train$neighbourhood_group_cleansed=="San Blas - Canillejas",]

ggplot(dataCan, aes(x=room_type, y=price, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("San Blas - Canillejas") + xlab("")

```

Comprobamos que no hay hoteles AirBnb en este distrito, que los precios de las habitaciones privadas se encuentran ligeramente por encima de los apartamentos, y las habitaciones compartidas quintuplican el precio de cualquiera de los anteriores. Esta comparativa no tiene en cuenta el número de personas que pueden utilizar el espacio, por lo que pasamos a representar el precio de cada espacio en función de esta variable:

```{r plCanillejasPP, fig.align="center", message=FALSE, warning=FALSE}

can <- ggplot(dataCan, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("San Blas - Canillejas") + xlab("")
can

```

Este resultado tiene aún menos sentido.


```{r countCanillejasPP, fig.align="center", message=FALSE, warning=FALSE}
count(dataCan %>% group_by(room_type))

```

Como hemos encontrado solo 6 habitaciones compartidas, nos tomaremos un momento para leer sus descripciones:

```{r descrWanda, fig.align="center", fig.height=15, fig.width=6, message=FALSE, warning=FALSE}

dataCan[dataCan$room_type=="Shared room","description"] 

```

Resulta que la palabra "wanda" está incluída en la mayoría. "wanda" se refiere al estadio "Wanda Metropolitano", el estadio del Club Atlético de Madrid, que se encuentra en el límite del distrito. Es plausible que los espacios cercanos al estadio sean alquilados a forofos del Atlético por un precio muy superior al del resto del distrito. Debido a ello, se dividirán los datos del distrito en dos: aquellas observaciones en las que se menciona el estadio y aquellas en las que no.


```{r divWanda, fig.align="center", fig.height=15, fig.width=6, message=FALSE, warning=FALSE}

cercaWanda <- dataCan[grep("wanda|estadio", tolower(dataCan$description)),]
lejosWanda <- anti_join(dataCan, cercaWanda)


cerca_wanda <- ggplot(cercaWanda, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + ggtitle("Cerca del estadio") + xlab("")
lejos_wanda <- ggplot(lejosWanda, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot() + scale_y_continuous(trans='log10')  + theme(legend.position="NONE") + ggtitle("Lejos del estadio") + xlab("")

grid.arrange(can, cerca_wanda, lejos_wanda, nrow=3, ncol=1)
```

Se puede concluir que los precios de los espacios compartidos de San Blas - Canillejas cercanos al estadio son superiores a los del resto del distrito. Estos espacios conformarán un nuevo distrito, que denominaremos "Wanda Metropolitano".

<br/>

```{r creaWanda, warning=FALSE}

data_train[rownames(cercaWanda),"neighbourhood_group_cleansed"] <- "Wanda Metropolitano"
data_train[rownames(cercaWanda),"neighbourhood_cleansed"] <- "Wanda Metropolitano"


```

```{r neighNoWanda, message=FALSE, warning=FALSE}

#neighNoWanda <- anti_join(data_train, cercaWanda)

ggplot(data_train, aes(x=reorder(neighbourhood_group_cleansed, price, FUN=median), y=price, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + xlab("neighbourhood_group_cleansed") + coord_flip() + theme(legend.position = "NONE") 

```

```{r neighNoWandaPP, message=FALSE, warning=FALSE}

#neighNoWanda <- anti_join(data_train, cercaWanda)

ggplot(data_train, aes(x=reorder(neighbourhood_group_cleansed, price_per_person, FUN=median), y=price_per_person, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + xlab("neighbourhood_group_cleansed") + coord_flip() + theme(legend.position = "NONE") + ylab("neighbourhood_group_cleansed")

```

El precio medio por distrito queda de la siguiente manera:

```{r mapamean, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price = mean(price), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price)) + scale_color_gradient(low = "blue", high = "red")

```


El precio medio por persona y distrito queda de la siguiente manera:

```{r mapameanPP, fig.align="center", warning=FALSE}

meanPriceByDistrict <- data_train %>% group_by(neighbourhood_group_cleansed) %>% summarize(mean_price_per_person = mean(price_per_person), longitude = longitude, latitude = latitude)

ggplot(meanPriceByDistrict, aes(x=longitude,y=latitude)) + geom_point(aes(colour=mean_price_per_person)) + scale_color_gradient(low = "blue", high = "red")

```


<br/>

#### Análisis del precio en función del tipo de habitación

A continuación, vamos a comparar la variable precio con una serie de variables de interés, para ver si relación utilizando técnicas de análisis multivariante y distintos tipos de gráficos.

```{r priceVSroomtype, fig.align="center", message=FALSE, warning=FALSE}
knit_exit()
# Price vs room type
price_rtyp <- ggplot(data_train, aes(x=room_type, y=price)) + geom_boxplot(outlier.size=0.2, lwd=0.25, color='black', fill='#4F94CD') + scale_y_continuous(trans='log10') + theme(axis.text.x = element_text(size=6, angle = 45, vjust = 0.25, hjust=0.25))


# price vs host_since
price_hs <- ggplot(data_train, aes(x=host_exp_days, y=price)) + geom_col(binwidth = 10, fill='#8B1C62') + scale_y_continuous(trans='log') # CHECK: Irrelevant TODO: agregar por promedio 

# price vs host_is_superhost
price_hisph <- ggplot(data_train, aes(x=host_is_superhost, y=price)) + geom_boxplot(outlier.size=0.2, lwd=0.25, color='black', fill='#FFA500') + scale_y_continuous(trans='log10') #CHECK: bit of an edge #FFA500

# price vs accommodates
pricevsAcco <- data_train %>%
  group_by(accommodates) %>%
  summarise(precio = mean(price))

price_acc <- ggplot(pricevsAcco, aes(x=accommodates, y=precio)) + geom_col(binwidth = 10, color='white', fill='#CD6839') # CHECK: Fairly obvious

# price vs bedrooms
pricevsBR <- data_train %>%
  group_by(bedrooms) %>%
  summarise(precio = mean(price))

price_bedr <- ggplot(pricevsBR, aes(x=bedrooms, y=precio)) + geom_col(binwidth = 10, color='white', fill='#8B2252') # CHECK: accommodates are better

# price vs beds
pricevsBeds <- data_train %>%
  group_by(beds) %>%
  summarise(precio = mean(price))

price_bds <- ggplot(pricevsBeds, aes(x=beds, y=precio)) + geom_col(binwidth = 10, color='white', fill='#698B22') # CHECK: Fairly obvious. Accommodates can be better.

# price vs minimum_nights
pricevsminimum_nights <- data_train %>%
  group_by(minimum_nights) %>%
  summarise(precio = mean(price))

price_nmin <- ggplot(pricevsminimum_nights, aes(x=minimum_nights, y=precio)) + geom_col(binwidth = 5,  fill='#8B3A62') # No value

# price vs minimum_nights_avg_ntm
pricevsminimum_nights_avg_ntm <- data_train %>%
  group_by(minimum_nights_avg_ntm) %>%
  summarise(precio = mean(price))

price_minavgn <- ggplot(pricevsminimum_nights_avg_ntm, aes(x=minimum_nights_avg_ntm, y=precio)) + geom_col(binwidth = 5, fill='#FFB90F') + scale_y_continuous(trans='log10') #¿?

# price vs maximum_nights_avg_ntm
pricevsmaximum_nights_avg_ntm <- data_train %>%
  group_by(maximum_nights_avg_ntm) %>%
  summarise(precio = mean(price))

price_maxavgn <- ggplot(pricevsmaximum_nights_avg_ntm, aes(x=maximum_nights_avg_ntm, y=precio)) + geom_col(binwidth = 5, fill='#528B8B') # No value

# price vs availability_365
pricevsavailability_365 <- data_train %>%
  group_by(availability_365) %>%
  summarise(precio = mean(price))

price_ava360 <- ggplot(pricevsavailability_365, aes(x=availability_365, y=precio)) + geom_col(binwidth = 5, fill='#8B1A1A') # CHECK: can seasonality be borrowed from here and scraping date?

# reviews_per_month vs price
p <- ggplot(data_train, aes(x=reviews_per_month, y=price, color=price, size=price)) + geom_point() + theme(legend.position="none")
price_rvpm <- ggMarginal(p, type="histogram",lwd=0.2,color='white', fill = "#FFC125", xparams = list(  bins=20),  size=6)

# review_scores_rating vs price
pr <- ggplot(data_train, aes(x=review_scores_rating, y=price, color=price, size=price)) + geom_point() + theme(legend.position="none")
price_rscr <- ggMarginal(pr, type="histogram",lwd=0.2,color='white', fill = "#FFC125", xparams = list(  bins=20),  size=6)

# grids
grid.arrange(price_rtyp, price_acc, price_bedr, price_bds, nrow =2, ncol=2)
grid.arrange(price_hs, price_hisph, price_rvpm, price_rscr, nrow =2, ncol=2)
grid.arrange(price_nmin, price_minavgn, price_maxavgn, price_ava360, nrow =2, ncol=2)
```

Hemos juntado los gráficos en rejillas de 4, tratando de agrupar por variables parecidas entre ellas para poder compararlas entre sí.

La primera comparativa, pone a la variable precio contra variables relacionadas con el tipo de habitación (room_type), camas (beds), número de habitaciones (bedrooms) y número de personas por AirBnb (accomodates).

Muy por encima, se aprecian detalles como que los apartamentos o **casas enteras** y las **habitaciones de hotel**, son **más caras** que habitaciones privadas dentro de una casa que habitaciones compartidas, ninguna sorpresa por aquí.

<br/>

En el segundo grupo de 4 gráficos, tenemos variables como el tipo de anfitrión (host is superhost), el tiempo que lleva en Airbnb (host_exp_days), y la relación con el número de reviews por mes y la nota media de las reviews.

Como conclusiones principales de esta comparativa, parece que el hecho de que el host sea **superhost no supone una diferencia** muy grande, sin embargo si que parece que el hecho de tener **reviews altas** produce cierto efecto en el **aumento del precio**.

<br/>

FInalmente, el último grupo de gráficos compara la variable precio con la cantidad de noches que se exigen como mínimo, como máximo y la disponibilidad en el plazo de un año.

A priori no parece que haya información muy interesante o determinante en estas variables y su relación con el precio.

<br/>

#### Análisis de la variable price, contra las variables ratings y distritos

Preparamos las variables para hacer el ploteado del heatmap.
Creamos nuevas variables de mean_ratings y mean_price con la media de cada una de estas variables por distrito, para su comparación con el precio.
Además, añadimos una variable más que no se encuentra en la tabla de datos original, el número de habitantes por distrito en 2017, por pura curiosidad.

```{r basemap, warning=FALSE}
price_dist_rating <- data_train %>% na.omit(data_train) %>%
  select(review_scores_rating, price, neighbourhood_group_cleansed)

price_dist_rating <- price_dist_rating %>%
  group_by(neighbourhood_group_cleansed) %>%
  summarise (mean_rating = mean(review_scores_rating), mean_price = mean(price))

head(price_dist_rating, 10)

# Añadimos población del 2017 por distrito
price_dist_rating$Poblacion_2017 = c(155660, 50010, 260196, 140473, 147551, 140866, 219867, 249973, 193264, 242139, 121683, 95614, 240867, 120406, 147854, 161222, 161313, 142894, 74048, 114512, 154318)
pdr_mat <- data.frame(price_dist_rating, row.names = 1)

#write.table(heatmap_df, file = "dataforheatmap.csv",
#            sep = "\t", row.names = F)
```

<br/>

Y a continuación el heatmap de la matriz creada anteriormente

```{r heatmap, fig.align="center", message=FALSE, warning=FALSE}
# Matrix format
mat <- pdr_mat
matriz <- as.matrix(mat)
heatmap(matriz, Colv = NA, Rowv = NA, scale="column", main=NA,cellnote=ifelse(matriz==0, NA, matriz), notecex=0.7,na.color=par("bg"), cexCol=0.7, col= colorRampPalette(brewer.pal(10, "YlOrRd"))(10))
# Heatmap
#d3heatmap(mat, scale="column", dendrogram = "none", width="800px", height="80Opx", colors = "Blues")

#heatmap(matriz, Colv = NA, Rowv = NA, scale="column")
```

El objetivo de este gráfico era realizar un análisis multivariante a tres bandas, cogiendo la variable objetivo y dos de las variables que más nos interesan.
Preliminarmente, esperabamos poder ver una clara relación entre estas variables, pero a nivel visual no hay nada demasiado evidente.
Algo que llama ligeramente la atención es la cierta "simetría" que parece haber entre las columnas de las reviews y la de la población, dónde hay una serie de todos más oscuros hacia el centro de las columnas.

Es interesante ver también como las medias de reviews más altas, se encuentran en barrios como Vicálvaro, Moratalaz, Monclia, Cuidad Lineal, Fuencarral... y sin embargo zonas como el Centro o Salamanca parecen tener reviews más bajas.

También se puede apreciar muy ligeramente que las zonas dónde hay más población, tienen quizás una menor media de precio, intuyendo que quizás haya menos cantidad de Airbnbs porque hay más población "autóctona".

<br/>



Podemos concluir que aunque no muy evidente, si se aprecia un cierto incremento de color naranja asociado a precios más altos, en los distritos localizados en el centro de la ciudad.

<br/> <br/>

#### Análisis y comparativa de variables host con variable ratings

```{r host, fig.align="center", message=FALSE, warning=FALSE}

# Host exp days
host_exp <- ggplot(data_train, aes(x=host_exp_days)) + geom_histogram(bins = 50, fill="darkslategray", col='white') + theme(legend.position = "none")

# Host is super host
host_sh <- ggplot(data_train, aes(x=host_is_superhost, fill =host_is_superhost, alpha = host_is_superhost)) + geom_histogram(stat='count', col= 'black', fill='darkorange3') +
  theme(axis.text.x = element_text(size=8)) + theme(legend.position = "none")

#Comparativa ratings con host
rs_rating_sh <- ggplot(data_train, aes(x = review_scores_rating, y=..count.., fill = host_is_superhost)) + geom_histogram(binwidth = 0.75, color='black', position='dodge', alpha = 1) + theme(legend.key.size = unit(0.3, 'cm'), legend.title = element_text(size = 6), legend.text = element_text(size = 6))+ xlab("Ratings")+ ylab("count")

grid.arrange(host_exp, host_sh, rs_rating_sh, ncol=2, nrow =2)
```

<br/><br/>

## Transformación de variables y eliminación de outliers

<br/>


Y a continuación, construimos gráficos para comparar la nueva variable con alguna de las variables previas, y ver realmente si las relaciones son mejores.

Comenzamos por la variable **room_type**

```{r propertyCostPerPerson, fig.height=7, fig.width=8, warning=FALSE, fig.align="center"}
rt_price_p <- ggplot(data_train, aes(x=room_type, y=price_per_person, fill=room_type)) + geom_boxplot(outlier.size=0.5, lwd=0.4, color='black') + scale_y_continuous(trans='log10') + theme(legend.position="NONE") + theme(legend.position="NONE") + theme(axis.text.x = element_text(size=8)) +xlab("")

rt_price <- price_rtyp <- ggplot(data_train, aes(x=room_type, y=price, fill=room_type)) + geom_boxplot(outlier.size=0.5, lwd=0.4, color='black') + scale_y_continuous(trans='log10') + theme(axis.text.x = element_text(size=8)) + theme(legend.position="NONE") +xlab("")

grid.arrange(rt_price_p, rt_price, nrow=1, ncol=2)
```

Vemos cierta **homogeneización** en los quartiles de los boxplot, y también en las medianas.
La transformación a precio por persona también nos deja ver que todos los tipos de habitación tienen un precio parecido de media, siendo la **habitación de hotel** la que más afecta al precio.

<br/>

Vamos a observar ahora la relación entre el precio por persona en función del **distrito**

```{r priceperbedVSneigh, fig.height=7, fig.width=9, warning=FALSE, fig.align="center"}
dist_precio_p <- ggplot(data_train, aes(x=reorder(neighbourhood_group_cleansed, price, na.rm=TRUE), y=price_per_person, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + coord_flip() + theme(legend.position="NONE") + xlab("Distritos") + ylab("Precio por persona/noche") + theme(axis.text = element_text(size = 7)) 

dist_precio <- data_train %>%
  ggplot(aes(x=(reorder(neighbourhood_group_cleansed,price ,na.mr=TRUE)), y=price, fill=neighbourhood_group_cleansed)) + geom_boxplot() + scale_y_continuous(trans='log10') + coord_flip() + theme(legend.position="none") + xlab("") + ylab("Precio") + theme(axis.text = element_text(size = 7)) 
grid.arrange(dist_precio_p, dist_precio, nrow =1, ncol=2)
```

Claramente, el **precio por persona fluctua menos** que el precio a la hora de compararlo **por distritos**. En general, se aprecia como los precios se agrupan **entre 10 y 50 doláres** de media por persona y noche, con algún **caso extraño** como es el de ***"Wanda Metropolitano".***

<br/>



<br/>

```{r exit}
knit_exit()
```

#### Eliminación de outliers



**Echa un ojo a este código Antonio, que da error**

```{r delOutliers, eval=FALSE, warning=FALSE, include=FALSE}

data_train <- data_train %>% mutate(pricePP = price/accommodates) data$ac #Este Código da error
umbral <- 150
plazas <- 10
data_train <- data_train[data_train$pricePP<umbral & data_train$acomm<=plazas]

```

<br/>



<br/><br/>

## Control de calidad del dato

<br/>

#### Deteccion de valores atipicos

Comprobamos si hay algunos datos atipicos en nuestro conjunto de datos.

```{r datos sum, echo=FALSE, warning=FALSE}
summary(data_train_del_na)
```

Vemos, que valores atipicos pueden tener las variables *accommodates*, *bedrooms*, *price*, *minimum_nights*, *reviews_per_month*, *last_review_days*, *host_listings_count*, *price_per_person*.
Revisamos estas variables mas detallado.

<br/>

Valores atipicos de variable accommodates

```{r datos acc graph, echo=FALSE, warning=FALSE}

plot(data_train_del_na$accommodates)

ggplot(data = data_train_del_na) +
   aes(x = accommodates) +
   geom_boxplot(outlier.colour = "Red", fill = "orange") +
   theme_bw()


ggplot(data = data_train_del_na) +
   aes(x = accommodates) +
   geom_dotplot(dotsize = 0.1,color = "green") +
   theme_minimal()
```

<br/>

Valores atipicos de variable bedrooms

```{r datos b graph, echo=FALSE, warning=FALSE}
plot(data_train_del_na$bedrooms)

ggplot(data = data_train_del_na) +
   aes(x = bedrooms) +
   geom_boxplot(outlier.colour = "Red", fill = "green") +
   theme_bw()


ggplot(data = data_train_del_na) +
   aes(x = bedrooms) +
   geom_dotplot(dotsize = 0.1,color = "blue") +
   theme_minimal()
```

<br/>

Valores atipicos de variable minimum_nights

```{r datos min_n graph, echo=FALSE, warning=FALSE}
plot(data_train_del_na$minimum_nights)

ggplot(data = data_train_del_na) +
   aes(x = minimum_nights) +
   geom_boxplot(outlier.colour = "Red", fill = "yellow") +
   theme_bw()

ggplot(data = data_train_del_na) +
   aes(x = minimum_nights) +
   geom_dotplot(dotsize = 0.1,color = "violet") +
   theme_minimal()
```

Variable de mínimos noches muestra la presencia de valores atípicos, por lo que requiere modificaciones.
Como es inusual que las noches mínimas estén por encima de 100 en cualquier airbnb, es claramente un valor atípico y debe eliminarse de nuestros datos.

<br/>

A continuación, guardamos los datos modificados en un nuevo dataset

```{r outliers nights, echo=FALSE, warning=FALSE}
# en primero vamos a guardardatos modificados en nuevo dataset data_train_clean para tener accesso de datos previos

data_train_clean <- data_train_del_na

uc1 = quantile(data_train_clean$minimum_nights, probs = 0.95, na.rm = TRUE)
  lc1 = quantile(data_train_clean$minimum_nights, probs = 0.05, na.rm = TRUE)
  data_train <- subset(data_train_clean, minimum_nights >= lc1 & minimum_nights <= uc1)

summary(data_train_clean$minimum_nights)
```

<br/>

Valores atipicos de variable price y price_per_person

```{r datos precio graph, echo=FALSE, warning=FALSE}
plot(data_train_clean$price)

ggplot(data = data_train_clean) +
   aes(x = price) +
   geom_boxplot(outlier.colour = "Red", fill = "blue") +
   theme_bw()


ggplot(data = data_train_clean) +
   aes(x = price) +
   geom_dotplot(dotsize = 0.1,color = "red") +
   theme_minimal()
```

```{r datos pr p graph, echo=FALSE, warning=FALSE}
plot(data_train_clean$price_per_person)

ggplot(data = data_train_clean) +
   aes(x = price_per_person) +
   geom_boxplot(outlier.colour = "Red", fill = "blue") +
   theme_bw()

ggplot(data = data_train_clean) +
   aes(x = price_per_person) +
   geom_dotplot(dotsize = 0.1,color = "red") +
   theme_minimal()
```

Variable de precios por persona muestra la presencia de valores atípicos, por lo que requiere modificaciones.
Como es inusual que la una noche para una persona vale 9000 euros.

```{r outliers price, echo=FALSE, warning=FALSE}

uc1 = quantile(data_train_clean$price_per_person, probs = 0.95, na.rm = TRUE)
  lc1 = quantile(data_train_clean$price_per_person, probs = 0.05, na.rm = TRUE)
  data_train <- subset(data_train_clean, price_per_person >= lc1 & price_per_person <= uc1)

summary(data_train_clean$price_per_person)
```

```{r outliers pr, echo=FALSE, warning=FALSE}
summary(data_train_clean$price)
```

```{r datos pr graph, echo=FALSE, warning=FALSE}

ggplot(data = data_train_clean) +
   aes(x = price) +
   geom_boxplot(outlier.colour = "Red", fill = "blue") +
   theme_bw()

ggplot(data = data_train_clean) +
   aes(x = price_per_person) +
   geom_boxplot(outlier.colour = "Red", fill = "blue") +
   theme_bw()
```

<br/>

Valores atipicos de variable minimum_nights

```{r datos m_n graph, echo=FALSE, warning=FALSE}
plot(data_train$minimum_nights)

ggplot(data = data_train) +
   aes(x = minimum_nights) +
   geom_boxplot(outlier.colour = "Red", fill = "yellow") +
   theme_bw()

ggplot(data = data_train) +
   aes(x = minimum_nights) +
   geom_dotplot(dotsize = 0.1,color = "violet") +
   theme_minimal()
```

<br/>

Valores atipicos de variable reviews_per_month

```{r datos r_m gr, echo=FALSE, warning=FALSE}

plot(data_train_clean$reviews_per_month)
   aes(x = reviews_per_month) +
   geom_boxplot(outlier.colour = "Red", fill = "violet") +
   theme_bw()


ggplot(data = data_train_clean) +
   aes(x = reviews_per_month) +
   geom_dotplot(dotsize = 0.1,color = "orange") +
   theme_minimal()
```

<br/>

Valores atipicos de variable last_review_days

```{r datos l_r graph, echo=FALSE, warning=FALSE}

plot(data_train_clean$last_review_days)

ggplot(data = data_train_clean) +
   aes(x = last_review_days) +
   geom_boxplot(outlier.colour = "Red", fill = "orange") +
   theme_bw()


ggplot(data = data_train_clean) +
   aes(x = last_review_days) +
   geom_dotplot(dotsize = 0.1,color = "navy") +
   theme_minimal()
```

<br/>

Valores atípicos de variable host_listings_count

```{r datos coun graph, echo=FALSE, warning=FALSE}
plot(data_train_clean$host_listings_count)

ggplot(data = data_train_clean) +
   aes(x = host_listings_count) +
   geom_boxplot(outlier.colour = "Red", fill = "orange") +
   theme_bw()

ggplot(data = data_train_clean) +
   aes(x = host_listings_count) +
   geom_dotplot(dotsize = 0.1,color = "navy") +
   theme_minimal()
```

```{r outliers count, echo=FALSE, warning=FALSE}

uc1 = quantile(data_train_clean$host_listings_count, probs = 0.95, na.rm = TRUE)
  lc1 = quantile(data_train_clean$host_listings_count, probs = 0.05, na.rm = TRUE)
  data_train <- subset(data_train_clean, host_listings_count >= lc1 & host_listings_count <= uc1)

summary(data_train_clean$host_listings_count)
```

```{r datos c out graph, echo=FALSE, warning=FALSE}
ggplot(data = data_train_clean) +
   aes(x = host_listings_count) +
   geom_boxplot(outlier.colour = "Red", fill = "orange") +
   theme_bw()
```

```{r outliers sresult, echo=FALSE, warning=FALSE}
summary(data_train_clean)
```

En resumen, eliminamos valores atipicos para variables *minimum_nights*, *price_per_person*, *host_listings_count*.

<br/> <br/>

#### Antonio, esta parte no corre el codigo bien... échale un ojo

```{r outliers, eval=FALSE, warning=FALSE, include=FALSE}

#outliers <- data_train[data$price > quantile(data_train$price)[4],]

#count(outliers)

#ggplot(outliers, aes(x=price)) + geom_histogram(binwidth = 10)

#ggplot(outliers, aes(y=price)) + geom_boxplot() + scale_y_continuous(trans = 'log10')

#outliers <- outliers %>% mutate(pricePP = price/accommodates)

#quantile(outliers$pricePP)

#outliersPerPerson <- outliers[(outliers$pricePP) > quantile(outliers$pricePP)[4],]

#ggplot(outliersPerPerson, aes(y=pricePP)) + geom_boxplot() + scale_y_continuous(trans = 'log10')

#count(outliersPerPerson[outliersPerPerson$pricePP > 1000, ])

#head(outliersPerPerson[outliersPerPerson$pricePP > 1000, "description"])

#insane <- outliersPerPerson[outliersPerPerson$pricePP > 1000,]

#count(insane)

#summary(insane)

#ggplot(insane, aes(x=price)) + geom_histogram()

#cuentaDistritosInsane <- insane %>%
#  group_by(neighbourhood_group_cleansed) %>%
#  summarise(count = n()) %>%
#  arrange(-count)

#ggplot(insane, aes(x=neighbourhood_group_cleansed)) + geom_histogram(stat='count')

#ggplot(insane, aes(x=room_type, y=pricePP)) + geom_boxplot()

#insane$accommodates

#insane$pricePP

#insane[insane$neighbourhood_group_cleansed=="Villaverde", c("description","price")]

#insane$reviews_per_month

# TODO Yo todo lo que supere los 105-150€/persona lo quitaba

```

<br/><br/>

## Modelo de Regresión Lineal: Ajuste, interpretación y diagnósis

<br/>

#### Correlación entre variables "a ojo"

```{r correlation, eval=FALSE, warning=FALSE, include=FALSE}

# TODO si se va a usar host_since, debería ser un entero hasta la última fecha

numericData <- data_train[,c("price", "pricePP","accommodates","bedrooms","beds","minimum_nights","availability_365","review_scores_rating","review_scores_location","review_scores_value","review_scores_accuracy","review_scores_cleanliness","review_scores_checkin","review_scores_communication")]

numericData <- data_train[,c("price", "pricePP","accommodates","bedrooms","beds","minimum_nights","availability_365","review_scores_location","review_scores_communication")]

ggcorrplot(cor(numericData), lab = TRUE) # Accommodates es la que mayor correlación muestra

```

<br/>

#### Regresión lineal multiple

```{r regression, warning=FALSE}
lm_fit <- lm(price~accommodates, data=data_train) #No hay duda de que el número de plazas influye
summary(lm_fit)


lm_fit <- lm(price~accommodates+bedrooms, data=data_train)
summary(lm_fit)

model <- lm(price~accommodates*bedrooms, data = data_train) # Incluiría Bedrooms. TODO: profundizar en el porqué.

summary(model)

#autoplot(model)

lm_fit <- lm(log(price)~accommodates:bedrooms+beds+minimum_nights+host_is_superhost+availability_365+room_type+neighbourhood_group_cleansed+review_scores_rating+review_scores_location+review_scores_value+review_scores_accuracy+review_scores_cleanliness+review_scores_checkin+review_scores_communication, data=data)
summary(lm_fit)

#autoplot(lm_fit)


lm_fit <- lm(price~longitude+latitude+accommodates:bedrooms+beds+minimum_nights+host_is_superhost+availability_365+room_type+neighbourhood_group_cleansed+review_scores_rating+review_scores_location+review_scores_value+review_scores_accuracy+review_scores_cleanliness+review_scores_communication, data=data)
summary(lm_fit) #Pasa algo muy interesante: al separar el Wanda del resto, la localización tiene más peso, y de repente el rating airbnb de location pierde todo su peso. El barrio no vale un duro, y sin embargo el distrito sí.

model <- lm(price~latitude+accommodates:bedrooms+beds+availability_365+room_type+neighbourhood_group_cleansed+review_scores_rating+review_scores_value+review_scores_cleanliness+review_scores_communication, data=data) # Al hacer log del precio, el R² queda casi 0.6


summary(model)

#autoplot(model)

# Regresión a saco:
#model <- lm_fit <- lm(log(price)~latitude+accommodates*beds*bedrooms+host_since+room_type+neighbourhood_cleansed+review_scores_rating+review_scores_location+review_scores_value+review_scores_cleanliness+number_of_reviews+number_of_reviews+number_of_reviews_l30d+maximum_nights_avg_ntm+maximum_nights+minimum_minimum_nights+maximum_maximum_nights+maximum_nights_avg_ntm+availability_30+instant_bookable+property_type+host_acceptance_rate+bathrooms_text+host_response_rate+host_location+host_response_time+host_identity_verified, data=data)

#summary(model)

#autoplot(model)


dataNum <- data_train[,unlist(lapply(data_train, is.numeric))]
dataNum$pricePP <- NULL

summary(lm_fit <- lm(log(price)~., data=dataNum)) # Al hacer log del precio, el R² queda casi 0.6


#regfit <- leaps::regsubsets(log(price)~.,data_train)

```

<br/> <br/>

<div class="toxicity-extend-page" data-unique="toxicity-extend-page" style="height:0;">
